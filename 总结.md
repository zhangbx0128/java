# Java基础

1、jdk、jre、SDK的区别

```
JDK是Java Development Kit.简单的说JDK是面向开发人员使用的SDK，它提供了Java的开发环境和运行环境。
SDK是Software Development Kit 一般指软件开发包，可以包括函数库、编译程序等。
JRE是Java Runtime Enviroment是指Java的运行环境，是面向Java程序的使用者，而不是开发者。
```

1、java 语言特点

2、面向对象和面向过程

3、八种基本数据类型及封装类（byte 1、short 2、int  4 、long 8 、double 8、float 4、char 2 、boolean 1）

3、三种引用类型（类、接口、数组）

4、标识符标（字母、$和下划线开始，不能数字开头，不能以关键词开始 ，大小写敏感）

5、变量作用域（类变量（静态变量）、实例变量（成员变量-无static修饰）、局部变量（类的方法中的变量））

5、instanceof （对象是否是一个类）

6、% 取余 5%3 =2  &&（同时为真）｜｜（满足一个） 

6、 x ? y : z  (score < 60 ? "不及格" : "及格")-(true 是 y false 是 z)

6、自动装箱拆箱（基本类型默认值0—包装器类型 int默认值空-->Integer）

```
包装类型可以为 null， 而基本类型不可以 。
包装类型可用于泛型， 而基本类型不可以 。
基本类型比包装类型更高效 。基本类型在栈中直接存储的具体数值，而包装类型则存储的是堆中的引用。
```

7、重载和重写（方法名、参数列表、返回值）

​	重载不能根据返回值类型区分

8、equals与==的区别（比较的是对象：变量(栈)内存中存放的对象的(堆)内存地址）比较基本数据类型：两个基本数据类型的值是否相等

9、Hashcode的作用（根据对象的内存地址换算出的一个值）

​	9.1集合的两类（list、set）

​	9.2 HashSet 

```
会计算对象的Hashcode的值来给出对象加入的位置，如果其他加入的对象没有和已经加入的hashcode值相同，就没有重复。
如果有相同的Hashcode值的对象，会调用equals（）方法检查是否相等，相等就不会让其加入，不同就散列到其他位置。
```

​	9.3 hashCode(),equals() 两种方法是什么关系?

```
如果两个对象 equals，Java 运行时环境会认为他们的 hashCode 一定相等。 
如果两个对象不 equals，他们的 hashCode 有可能相等。 
如果两个对象 hashCode 相等，他们不一定 equals。 
如果两个对象 hashCode 不相等，他们一定不 equals
```

10、String、String Buffer（线程安全、同步锁）、StringBUilder

​		1、String为什么要设计成不可变的？

```
1.便于实现字符串池（String pool）
2.使多线程安全
3.避免安全问题
4.加快字符串处理速度
```

11、ArrayList和linkedList的区别（查找和添加删除）

12、HashMap和HashTable的区别（父类、接口、Null、安全性、容量、计算hash）

13、Collection包结构，与Collections的区别(Collections是集合类的一个帮助类)

14、Java四种引用（强弱软虚）内存不足时、ReferenceQueue

15、泛型（意味着编写的代码可以被不同类型的对象所重用）如ArrayList	

​		1、Java中的泛型是什么 ?

​			泛型就是将类型参数化， 其在编译时才确定具体的参数-泛型类、泛型接口、泛型方法

​		2、什么是泛型中的限定通配符和非限定通配符 ?

```
一种是<? extends T>它通过确保类型必须是T的子类来设定类型的上界，
一种是<? super T>它通过确保类型必须是T的父类来设定类型的下界。
泛型类型必须用限定内的类型来进行初始化，否则会导致编译错误。
```

​		3、Array中不可以使用泛型-建议使用List代替Array.因为 List 可以提供编译期的类型安全保证

16、java创建对象的几种方式(new、反射、clone、序列化)

17、两个不相等的对象有相同的hashcode（拉链法、开放定址法、再哈希）

18、深拷贝和浅拷贝（深拷贝把要复制的对象所引用的 对象都复制了一遍.）

19、final 有那些用法(不可继承、重写、改变)

20、static有那些用法（静态变量、方法、静态内部类）

21、 3*0.1 == 0.3返回值是什么（false，浮点数）

22、a=a+b和a+=b有什么区别（+= 操作符会进行隐式自动类型转换， 对右边的结果强转匹配左边的数据类型,）

23、try catch ﬁnally，try里有return，ﬁnally还执行么？（执行）

24、 Excption与Error包结构（CheckedException，RuntimeException，Error）

25、OOM你遇到过哪些情况，SOF你遇到过哪些情况（前：GC；后：递归）

26、 简述线程、程序、进程的基本概念。以及他们之间关系是什么?

27、Java 序列化中如果有些字段不想进行序列化，怎么办？（transient）

28、说说Java 中 IO 流（输入流输出流，字节流字符流，节点流处理流）

​		1、字节流如何转为字符流？

```
字节输入流转字符输入流通过 InputStreamReader 实现，该类的构造函数可以传入 InputStream 对 象。
字节输出流转字符输出流通过 OutputStreamWriter 实现，该类的构造函数可以传入 OutputStream 对 象。
```

​	2、既然有了字节流,为什么还要有字符流?

```
字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是⾮常耗时，并且， 如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就⼲脆提供了⼀个直接操作 字符的接⼝，⽅便我们平时对字符进⾏流操作。如果⾳频⽂件、图⽚等媒体⽂件⽤字节流⽐ 较好，如果涉及到字符的话使⽤字符流⽐较好。
```

29、 Java IO与 NIO的区别（JDK1.4 用到的是块）

30、java反射的作用与原理（jdbc）

```
反射是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都 能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为 Java 语言 的反射机制。
```

​	30.1 Class.forName('com.mysql.jdbc.Driver.class');//加载MySQL的驱动类

```java
获取反射中的Class对象
Class clz = Class.forName("java.lang.String");//
Class clz = String.class;
String str = new String("Hello"); Class clz = str.getClass();
```

​	30.2 反射的实现方式

​	30.3 实现Java反射的类

```
class，反射的核心类，可以获取类的属性，方法等信息。
field:表示类中的成员变量，可以用来获取和设置类之中的属性值。
Constructor：表示类中的构造方法， 
Method：表示类中的方法它可以用来获取类中的方法信息或者执行 方法。
forName、getField、getDeclaredField、getMethod、getConstructor、setAccessible、invoke
```

​	30.4 反射的缺点

​	30.5 反射机制的应用有哪些？

​		1、JDBC的数据库连接

```
1. 通过Class.forName()加载数据库的驱动程序 （通过反射加载，前提是引入相关了Jar包）；
2. 通过 DriverManager 类进行数据库的连接，连接的时候要输入数据库的连接地址、用户名、密 码；
3. 通过Connection 接口接收连接。
```

​		2、Spring框架的使用， 最经典的就是 xml的配置模式 。



31、List、Set、Map三者区别（有序，独一，键值对）

32、Object 有哪些常用方法？（clone、finalize、equal、hashcode、wait、notify、notif yall）

33、java 创建对象有哪几种方式（new创建新对象、通过反射机制、采用clone机制、通过序列化机制）

34、获取一个类对象的方式（getclassa、类的静态成员、getclass）

35、ArrayList和LinkedList区别（扩容、指针）

36、ArrayList的特点(ArrayList 实现了 Cloneable 接口、浅复制)

37、有数组了为什么还要搞个 ArrayList 呢？（自动扩容）

38、说说什么是 fail-fast？（Java 集合中的错误机制。多个线程对同一个集合的内容进行 操作）

39、说说Hashtable 与 HashMap 的区别（版本、继承、线程安全、key null、扩容11 2n+1 16 2^n  ）

40、HashMap 中的 key 我们可以使用任何类作为 key 吗？

41、HashMap 的长度为什么是 2 的 N 次方呢？(减少 hash 值的碰撞、取余） 

42、HashMap 与 ConcurrentHashMap 的异同（KV、线程安全、底层数据结构、初始大小扩容、分段锁）

43、红黑树有哪几个特征？

44、说说你平时是怎么处理 Java 异常的（try、catch、finally）

45、说说深拷贝和浅拷贝？（是否申请新内存）

```
1. 浅拷⻉：对基本数据类型进⾏值传递，对引⽤数据类型进⾏引⽤传递般的拷⻉，此为浅 拷⻉。

2. 深拷⻉：对基本数据类型进⾏值传递，对引⽤数据类型，创建⼀个新的对象，并复制其 内容，此为深拷⻉。
```

46、值传递和引用传递的区别的什么？为什么说Java中只有值传递

```
值传递：方法调用时，传递的参数是按值的拷贝传递、传递后不相关
引用传递：方法调用时，传递的是引用的地址，变量对应的内存空间的地址，传递前后都是同一个引用
```

47、字符型常量和字符串常量的区别？

```
字符常量是单引号引起的一个字符'a'，相当于一个整型值( ASCII 值),可以参加表达式运算；占2个字节
字符串常量是双引号引起的若干个字符"aaaa"代表一个地址值 (该字符串在内存中存放位置，相当于对象；占若干个字节
char 在Java中占两个字节
```

48、什么是字符串常量池？-全局字符串常量池 ， class文件常量池 ， 运行时常量池

```
jvm为了提升性能和减少内存开销，避免字符的重复创建，其维护了一块特殊的内存空间，即字符串池，
当需要使用字符串时，先去字符串池中查看该字符串是否已经存在，如果存在，则可以直接使用，如果不存在，初始化，并将该字符串放入字符串常量池中。
常量池的位置在永久代（方法区）在jdk8中，永久代（方法区）被元空间取代了。
```

49、String有哪些特性?

```
不变性：String 是只读字符串，是一个典型的 immutable 对象，对它进行任何操作，其实都是创 建一个新的对象，再把引用指向该对象。不变模式的主要作用在于当一个对象需要被多线程共享并 频繁访问时，可以保证数据的一致性； 
常量池优化：String 对象创建之后，会在字符串常量池中进行缓存，如果下次创建同样的对象时， 会直接返回缓存的引用； final：使用 final 来定义 String 类，表示 String 类不能被继承，提高了系统的安全性。
```

50、两个new生成的Integer变量的对比（不同）因为new生成的是两个对象，其内存地址不同

51、Integer变量和int变量比较时，只要两个变量的值是向等的，则结果为true

52、非new生成的Integer变量和new Integer()生成的变量比较时，结果为false。

```
因为非new生成的Integer变量指向的是java常量池中的对象，而newInteger()生成的变量指向堆中新建的对象，两者在内存中的地址不同
```

53、序列化与反序列化是什么？

```
对内存中的对象进行持久化或网络传输 , 这个时候都需要序列化和反序列化
1.对象序列化可以实现分布式对象。
2.对象序列化不仅保留一个对象的数据， 而且递归保存对象引用的每个对象的数据。
3.序列化可以将内存中的类写入文件或数据库中。
4.对象、文件、数据， 有许多不同的格式， 很难统一传输和保存。
```

54、序列化实现的方式有哪些？

```
实现Serializable接口或者Externalizable接口。
```

55、Error和Exception区别是什么

```
Throwable 类有两个 重要的子类 Exception （异常）和 Error （错误）。
```

55、throw和throws的区别 

```
区别一：throw 是语句抛出一个异常；throws 是方法抛出一个异常；
区别二：throws可以单独使用，但throw不能；
区别三：throw要么和try-catch-finally语句配套使用，要么与throws配套使用。但throws可以单独使用，然后再由处理异常的方法捕获。

```

56、非受检查异常 运行时异常 和受检查异常 一般异常 区 别是什么

```
非受检查异常和受检查异常之间的区别 ：是否强制要求调用者必须处理此异常，如果强制要求调用者必须进行处理，那么就使用受检查异常，否则就选择非受检查异常。
```

57、try-catch-finally中哪个部分可以省略？

```
Try 处理运行时异常
catch 捕获显示声明进一步处理
finall 扫尾处理
```

58、JVM是如何处理异常的？

```
一个方法发生异常，方法创建一个异常对象，转发给JVM（抛出异常）
可能有一系列的方法调用才进入抛出异常的方法，这一系列方法的调用的有序列表叫做调用栈
JVM顺着调用栈查看是否有可以处理异常的代码，有的话传给它处理，没有的话将该异常转交给默认的异常处理器，默认处理器打印出异常处理器，并终止应用程序。
```

59、关键字

```
1、final 修饰的类不能继承，修饰的方法不能被重写，修饰的变量是常量，初始化后不能被修改
2、static 
3、this
4、super
```

59、反射读取注解

```java
//1.定义注解 , 
// 2.在类中使用注解 , 
// 3. 使用反射获取注解 , 一般都是现成框架实现 , 我们手动实现
//反射 , Class可以获得类的全部信息 , 所有的东西 
Class clazz = Class.forName("com.annotation.Student");
//获得这个类的注解 
Annotation[] annotations = clazz.getAnnotations();
//获得类的注解value的值 
TableKuang table = (TableKuang) clazz.getAnnotation(TableKuang.class);
//获得类指定注解的值 
Field name = clazz.getDeclaredField("name");

//获得class办法一:通过对象获得 
Class clazz1 = person.getClass();
//获得class办法二:通过字符串获得(包名+类名) 
Class clazz2 = Class.forName("com.reflection.Student");
//获得class办法三:通过类的静态成员class获得 
Class clazz3 = Person.class;
//获得class办法四:只针对内置的基本数据类型 
Class clazz4 = Integer.TYPE;
//获得父类类型 
Class clazz5 = clazz2.getSuperclass();
```

60、反射

```
优点：可以实现动态创建对象和编译，体现出很大的灵活性 !
缺点：对性能有影响。使用反射基本上是一种解释操作，操作总是慢于 直接执行相同的操作。
```

![image-20220504182456460](/Users/zhangdada/Library/Application Support/typora-user-images/image-20220504182456460.png)

![image-20220504182954398](/Users/zhangdada/Library/Application Support/typora-user-images/image-20220504182954398.png)

# JAVA集合



Java集合类主要由两个根接口Collection和Map派生，Collection派生出三个接口：List、Set、Queue。

Collection是一个接口、Collections是一个工具类

![image-20220331110214032](/Users/zhangdada/Library/Application Support/typora-user-images/image-20220331110214032.png)

![image-20220331110811535](/Users/zhangdada/Library/Application Support/typora-user-images/image-20220331110811535.png)

1、三大集合的区别 （set、map、list）

1、线程安全的集合有

```
1、Hashtable 2、ConcurrentHashMap 3、Vector 4、Stack
```

线性不安全的：

```
1、HashMap 2、Arraylist 3、LinkedList 4、HashSet 5、TreeSet 6、TreeMap
TreeMap 主要多了对集合中的元素根据键排序的能力以及 对集合内元素的搜索的能力，相比于 HashMap 来说
```

3. Arraylist与 LinkedList 异同点？

   ```
   1、线程安全（都不）
   2、底层数据结构不同（基于Objec数组和双向循环链表）
   3、前者适合用于查询的情况、后者适用于插入删除
   4、内存占用（ArrayList需要在列表的尾部预留一定的空间、而LinkedList需要更多的空间存放直接后继、直接前驱以及数据）
   ```

4、ArrayList与 Vector 区别？

```
1、线程安全
2、扩容（ArrayList在底层数组不够用时在原来的基础上扩展0.5倍，Vector是扩展1倍，前者就有利于节约内存空间）
```

5、说一说ArrayList 的扩容机制？

```
ArrayList扩容的本质就是计算出新的扩容数组的size后实例化，并将原有数组内容复制到新数组中去。默认情况下， 新的容量会是原容量的1.5倍
```

6、Array和ArrayList有什么区别

```
1、Array可以包含基本类型和对象类型，ArrayList只能包含对象类型
2、Array大小是固定的
3、ArrayList提供了更多的方法和特性 addAll();removeAll();iterator()
```

7、HashMap的底层数据结构是什么？

```
在JDK1.7 中，由“数组+链表”组成，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在 的。
在JDK1.8 中，由“数组+链表+红黑树”组成。当链表过长，则会严重影响 HashMap 的性能，红黑树搜索 时间复杂度是 O(logn)，而链表是糟糕的 O(n)。因此，JDK1.8 对数据结构做了进一步的优化，引入了红 黑树，链表和红黑树在达到一定条件会进行转换：
当链表超过 8 且数据总量超过 64 才会转红黑树。 
将链表转换成红黑树前会判断，如果当前数组的长度小于 64，那么会选择先进行数组扩容，而不 是转换为红黑树，以减少搜索时间。
```

8、解决hash冲突的办法有哪些？HashMap用的哪种？

```
解决Hash冲突方法有:开放定址法、再哈希法、链地址法（拉链法）、建立公共溢出区。
HashMap中采 用的是 链地址法 。
```

9、为什么在解决 hash 冲突的时候，不直接用红黑树？而 选择先用链表，再转红黑树?

```
因为红黑树需要进行左旋，右旋，变色这些操作来保持平衡，而单链表不需要。
当元素小于 8 个的时 候，此时做查询操作，链表结构已经能保证查询性能。
当元素大于 8 个的时候， 红黑树搜索时间复杂度 是 O(logn)，而链表是 O(n)，
此时需要红黑树来加快查询速度，但是新增节点的效率变慢了。
```

10、HashMap默认加载因子是多少？为什么是 0.75，不是0.6 0.8

```
Load factor为负载因子(默认值是0.75)，threshold是HashMap所能容纳键值对的最大值。
threshold = length * Load factor。也就是说，在数组定义好长度之后，负载因子越大，所能容纳的键值对个数越多。
```

11、HashMap中 key 的存储索引是怎么计算的？

```
首先根据key的值计算出hashcode的值，然后根据hashcode计算出hash值，最后通过hash&（length1）计算得到存储的位置。
```

12、HashMap的put方法流程？

```
1. 首先根据 key 的值计算 hash 值，找到该元素在数组中存储的下标；
2. 如果数组是空的，则调用 resize 进行初始化；
3. 如果没有哈希冲突直接放在对应的数组下标里；
4. 如果冲突了，且 key 已经存在，就覆盖掉 value；
5. 如果冲突后，发现该节点是红黑树，就将这个节点挂在树上；
6. 如果冲突后是链表，判断该链表是否大于 8 ，如果大于 8 并且数组容量小于 64，就进行扩容；如 果链表节点大于 8 并且数组的容量大于 64，则将这个结构转换为红黑树；否则，链表插入键值 对，若 key 存在，就覆盖掉 value。
```

13、HashMap的扩容方式

```
方法 是将 HashMap 的大小扩大为原来数组的两倍，并将原来的对象放入新的数组中。
```

14、一般用什么作为HashMap的key?

```
一般用Integer、String 这种不可变类当 HashMap 当 key，而且 String 最为常用。
```

15、HashMap为什么线程不安全？

```
1、多线程下扩容死循环。
JDK1.7使用头插法插入元素，在多线程的环境下，扩容的时候有可能导致环形链表的出现，形成死循环。
JDK1.8使用尾插法插入元素，在扩容时会保持链表元素原本的顺序，不会出现环形链表的问题。 
2、多线程的put可能导致元素的丢失。
多线程同时执行 put 操作，如果计算出来的索引位置是相同的，那会造成前一个key被后一个key覆盖，从而导致元素的丢失。
3、put和get并发时，可能导致get为null。
线程1执行put时，因为元素个数超出threshold而导致 rehash，
线程2此时执行get，有可能导致这个问题。
```

16、ConcurrentHashMap的实现原理是什么？

```
JDK1.7中的ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成，即 ConcurrentHashMap 把哈希桶切分成小数组（Segment ），每个小数组有 n 个 HashEntry 组成。
其中，Segment 继承了 ReentrantLock，所以 Segment 是一种可重入锁，扮演锁的角色；HashEntry 用于存储键值对数据。
首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据 时，其他段的数据也能被其他线程访问，能够实现真正的并发访问。

JDK1.8，在数据结构上， JDK1.8 中的ConcurrentHashMap 选择了与 HashMap 相同的 数组+链表+红黑树 结 构；在锁的实现上，抛弃了原有的 Segment 分段锁，采用 CAS + synchronized 实现更加低粒度的锁。
将锁的级别控制在了更细粒度的哈希桶元素级别，也就是说只需要锁住这个链表头结点（红黑树的根节 点），就不会影响其他的哈希桶元素的读写，大大提高了并发度。
```

17、ConcurrentHashMap 的 put 方法执行逻辑是什么？

```
1. 根据 key 计算出 hash值。
2. 判断是否需要进行初始化。
3. 定位到 Node，拿到首节点 f，判断首节点 f：
如果为 null ，则通过cas的方式尝试添加。 
如果为 f.hash = MOVED = -1 ，说明其他线程在扩容，参与一起扩容。 
如果都不满足 ，synchronized 锁住 f 节点，判断是链表还是红黑树，遍历插入。 
4. 当在链表长度达到8的时候，数组扩容或者将链表转换为红黑树。
```

18、ConcurrentHashMap的 get 方法是否要加锁，为什么 

```
get 方法不需要加锁。因为 Node 的元素 val 和指针 next 是用 volatile 修饰的，在多线程环境下线程A 修改结点的val或者新增节点的时候是对线程B可见的。
```

19、get方法不需要加锁与volatile修饰的哈希桶有关吗？

```
没有关系。哈希桶 table 用volatile修饰主要是保证在数组扩容的时候保证可见性。
```

20、ConcurrentHashMap 不支持 key 或者 value 为null的原因？

```
因为 ConcurrentHashMap 是用于多线程的 ，如果 map.get(key) 得到了 null ，
无法判断，是映射的value是 null ，还是没有找到对应的key而为 null ， 这就有了二义性。
```

21、ConcurrentHashMap 的并发度是多少？

```
在JDK1.7中，并发度默认是16，ConcurrentHashMap 会使用大于等于该值的最小的2的幂指数作为实际并发度，也就是比如你设置的值 是17，那么实际并发度是32。
```

22. ConcurrentHashMap 迭代器是强一致性还是弱一致性？

```
与HashMap迭代器是强一致性不同，ConcurrentHashMap 迭代器是弱一致性。
ConcurrentHashMap 的迭代器创建后，就会按照哈希表结构遍历每个元素，但在遍历过程中，内部元 素可能会发生变化，如果变化发生在已遍历过的部分，迭代器就不会反映出来，而如果变化发生在未遍 历过的部分，迭代器就会发现并反映出来，这就是弱一致性。
这样迭代器线程可以使用原来老的数据，而写线程也可以并发的完成改变，更重要的，
这保证了多个线程并发执行的连续性和扩展性，是性能提升的关键。
```

23. JDK1.7 与JDK1.8 中ConcurrentHashMap 的区别？

```
1、数据结构：：取消了Segment分段锁的数据结构，取而代之的是数组+链表+红黑树的结构。
2、线程安全机制：用Segment的分段锁机制、采用CAS+Synchronized保证线程安全。
3、锁的粒度：原来是对需要进行数据操作的Segment加锁，现调整为对每个数组元素加锁 （Node）。
4、链表化成红黑树：在链表节点数量大于8 时，会将链表转化为红黑树进行存储。
5、查询时间复杂度：：从原来的遍历链表O(n)，变成遍历红黑树O(logN)。
```

24. ConcurrentHashMap 和Hashtable的效率哪个更高？为什么？

```
ConcurrentHashMap 的效率要高于Hashtable，因为Hashtable给整个哈希表加了一把大锁从而实现线 程安全。而ConcurrentHashMap 的锁粒度更低，在JDK1.7中采用分段锁实现线程安全，在JDK1.8 中采 用 CAS+Synchronized 实现线程安全。
```

25. 说一下Hashtable的锁机制 ?

```
Hashtable是使用Synchronized来实现线程安全的，给整个哈希表加了一把大锁，多线程访问时候，只 要有一个线程访问或操作该对象，那其他线程只能阻塞等待需要的锁被释放，在竞争激烈的多线程场景 中性能就会非常差！
```

27. HashSet 和 HashMap 区别?

```
1、实现的接口不同
2、存储对象不同（键值对、仅对象）
3、加入方式 PUT、ADD
4、计算hashcode值
5、重复K值会覆盖 而 set会直接返回false
```

29. Iterator 和 ListIterator 有什么区别？

```
遍历。使用Iterator，可以遍历所有集合，如Map，List，Set；但只能在向前方向上遍历集合中的 元素。
使用ListIterator，只能遍历List实现的对象，但可以向前和向后遍历集合中的元素。
添加元素。Iterator无法向集合中添加元素；而，ListIteror可以向集合添加元素。 
修改元素。Iterator无法修改集合中的元素；而，ListIterator可以使用set()修改集合中的元素。 
索引。Iterator无法获取集合中元素的索引；而，使用ListIterator，可以获取集合中元素的索引。
```

30.讲一讲快速失败(fail-fast)和安全失败(fail-safe)

```
快速失败（ fail—fast）
在用迭代器遍历一个集合对象时，如果遍历过程中对集合对象的内容进行了修改（增加、删除、修 改），则会抛出Concurrent Modification Exception。
场景：java.util包下的集合类都是快速失败的，不能在多线程下发生并发修改（迭代过程中被修 改），比如HashMap、ArrayList 这些集合类。
安全失败（ fail—safe）
采用安全失败机制的集合容器，在遍历时不是直接在集合内容上访问的，而是先复制原有集合内 容，在拷贝的集合上进行遍历。
迭代器并不 能访问到修改后的内容
场景：java.util.concurrent包下的容器都是安全失败，可以在多线程下并发使用，并发修改，比 如：ConcurrentHashMap。
```

# IO流

![image-20220504160142421](/Users/zhangdada/Library/Application Support/typora-user-images/image-20220504160142421.png)

# JVM

![image-20220323203306068](/Users/zhangdada/Library/Application Support/typora-user-images/image-20220323203306068.png)

.java 编译后生成.class送入JVM方法区、堆、栈

其实也不用管太多，只需要知道对象实例初始化时会去方法区中找类信息，完成后再到 栈那里去运行方法。找方法就在方法表中找。

栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数 据。

1、jvm内存模型（堆、栈、本地方法栈、程序计数器、方法区、内存可见性）

```
方法区：
1. 有时候也成为永久代，在该区内很少发生垃圾回收，但是并不代表不发生 GC，在这里进行的 GC 主要是对方法区里的常量池和对类型的卸载
2. 方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。
3. 该区域是被线程共享的。
4. 方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。

虚拟机栈:

1. 虚拟机栈也就是我们平常所称的栈内存,它为 java 方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。
2. 虚拟机栈是线程私有的，它的生命周期与线程相同。
3. 局部变量表里存储的是基本数据类型、returnAddress 类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定
4.操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式
5.每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接.动态链接就是将常量池中的符号引用在运行期转化为直接引用。

本地方法栈
本地方法栈和虚拟机栈类似，只不过本地方法栈为 Native 方法服务。

堆
java 堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。

程序计数器
内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个 java 虚拟机规范没有规定任何 OOM 情况的区域。
```

2、JMM（原子性、可见性、有序性）

3、类加载与卸载（加载、｜验证、准备、解析｜（连接）、初始化、使用、卸载）

4、双亲委派机制

5、分代回收（年轻代->标记-复制  老年代->标记-清除 ）

6、GC回收算法（G1、ZGC、）

7、堆和栈的区别（堆：存储Java对象 栈：运行单位局部变量和 方法调用）栈线程私有、堆线程共享、异常错误不同、空间大小栈小

8、什么时候出发FullGC（旧生代空间不足、Permanent Generation）

9、什么是Java虚拟机？为什么Java被称作是“平台无关的编程语 言”？

![image-20220323204630090](/Users/zhangdada/Library/Application Support/typora-user-images/image-20220323204630090.png)

10、说说对象分配规则

11、描述一下JVM加载class文件的原理机制？

12、说说Java对象创建过程

13、知道类的生命周期吗？（加载、连接、初始化、使用和卸载）

14、简述Java的对象结构（对象头、实例数据、对齐填充）

15、如何判断对象可以被回收？（引用计数（循环引用）、可达性分析）

```
这里GCRoots包含了四种类型的对象，以第一种“a.虚拟机栈(栈桢中的本地变量表)中的引用的对象”举例。
首先说一下栈帧，栈帧是不会被线程共享的，一个方法从调用开始到执行完成，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。也就是说当前栈帧中存在的对象就可以判定为是不会回收的对象，知道这一点，就好理解后面的东西了。
比如存在对象A和对象B，此时对象A存在于栈帧中，而对象A又引用了对象B，也就是从A这个GCRoots作为起点向下搜索的引用链中包括了对象B，然后B没有引用其他任何对象，这个时候以对象A作为GCRoots起点的可达性分析过程就完成了，里面包含了对象A和B两个对象，那么这两个对象就不会被回收。这就是一个可达性分析的过程。  其实理解可达性分析，首先要理解GCRoots，上面四种GCRoots都有一个共同的特点，就是只要他们存在，就意味着不会被回收，那么他们引用到的对象也就不会被回收，这就是可达性分析的原理
但一个对象满足上述条件的时候，不会马上被回收，还需要进行两次标记；第一次标记：判断当前对象 是否有finalize()方法并且该方法没有被执行过，若不存在则标记为垃圾对象，等待回收；若有的话，则 进行第二次标记；第二次标记将当前对象放入F-Queue队列，并生成一个finalize线程去执行该方法，虚 拟机不保证该方法一定会被执行，这是因为如果线程执行缓慢或进入了死锁，会导致回收系统的崩溃； 如果执行了finalize方法之后仍然没有与GC Roots有直接或者间接的引用，则该对象会被回收；
在 java 中可以作为 GC Roots 的对象有以下几种
虚拟机栈中引用的对象
方法区类静态属性引用的对象
方法区常量池引用的对象
本地方法栈 JNI 引用的对象
```

16、JVM的永久代中会发生垃圾回收么？（满了Full GC）

17、你知道哪些垃圾收集算法（标记 -清除算法、复制算法、标记-压缩算法）

```
1.标记-清除:
思想就是标记哪些要被回收的对象，然后统一回收。
问题：1.效率不高，标记和清除的效率都很低；2.会产生大量不连续的内存碎片，导致以后程序在分配较大的对象时，由于没有充足的连续内存而提前触发一次 GC 动作。
2.复制算法:
复制算法将可用内存按容量划分为相等的两部分，然后每次只使用其中的一块，当一块内存用完时，就将还存活的对象复制到第二块内存上，将内存划分为8:1:1 三部分
3.标记-整理：
为了解决标记-清除，产生大量内存碎片的问题
是在清除对象的时候现将可回收对象移动到一端，然后清除掉端边界以外的对象，这样就不会产生内存碎片了。
4.分代收集 
新生代中复制算法
老年代里标记-整理 或者 标记-清除。
```

18、调优命令有哪些？（Sun JDK监控和故障处理命令有jps jstat jmap jhat jstack jinfo）

19、常见调优工具有哪些（jconsole和jvisualvm、三方MAT、GChisto。）

20、Minor GC与Full GC分别在什么时候发生？前：新生代内存不够用  后：JVM内存不够 

21、你知道哪些JVM性能调优参数？（堆内存大小）设定新生代大小 设定垃圾回收器

```
调整最大堆内存和最小堆内存
-Xmx –Xms：指定java堆最大值（默认值是物理内存的1/4(<1GB)）和初始java堆最小值 （默认值是物理内存的1/64(<1GB))
根据实际事情调整新生代和幸存代的大小，官方推荐新生代占java堆的3/8，幸存代占新 生代的1/10
```

22、对象一定分配在堆中吗？有没有了解逃逸分析技术？

23、虚拟机为什么使用元空间替换了永久代？

24、什么是Stop The World ? 什么是OopMap？什么是安全 点？

25、说一下JVM 的主要组成部分及其作用？两个子系统和两个组件

26、什么是指针碰撞？（空闲内存与非空中间放着一个指针作为分界点的指示器，）

27、什么是空闲列表？（Java堆内存中的内存并不是规整的在分配的时候从列表找到一块 大的空间分配给对象实例，并更新列表上的记录，这种分配方式就是空闲列表。）

28，什么是TLAB？（Thread Local Allocation Buﬀer，本地线程分配缓存）

29、对象头具体都包含哪些内容？（Mark Word、存储类型指针）

30、你知道哪些JVM调优参数？（堆栈内存相关、垃圾收集器、辅助信息）

31、说一下 JVM 有哪些垃圾回收器？

```
新生代收集器：Serial、 ParNew 、 Parallel Scavenge 
老年代收集器： CMS 、Serial Old、Parallel Old
整堆收集器： G1 ， ZGC (因为不涉年代不在图中)。
```

32、如何选择垃圾收集器？（堆大小、串并行、停顿、响应时间）

33、 什么是类加载器？（源码、编译、类、字节码、文件）

34、什么是 tomcat 类加载机制？

35、Java如何实现多态（编译时多态、运行时多态）-继承、重写、向上转型

```
（父类的引用指向子类）
//Student 可以调用自己本身或者继承过来的方法
Student s1 = new Student(); 
//person  只能使用自己方法 如果调用子类的方法需要强转 ((student) s2).eat();
Person s2  = new Person();
```

36、抽象类和接口的区别（）

```
抽象类可以提供成员方法的实现细节，而接口中只能存在public abstract 方法； 
抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是public static final类型的；
接口中不能含有静态代码块以及静态方法，而抽象类可以有静态代码块和静态方法； 
一个类只能继承一个抽象类，而一个类却可以实现多个接口。
设计层面上的区别：
抽象类是对一种事物的抽象，即对类抽象，而接口是对行为的抽象。抽象类是对整个类整体进行抽 象，包括属性、行为，
但是接口却是对类局部（行为）进行抽象。 设计层面不同，抽象类作为很多子类的父类，它是一种模板式设计。
而接口是一种行为规范，它是 一种辐射式设计。
```

谈谈 JVM 中的常量池？

```
JVM常量池主要分为Class文件常量池、运行时常量池， 全局字符串常量池， 以及基本类型包装类对象常量池
```



# 多线程、并发（原子性、可见性、有序性）

```
普通方法直接调用 t.run()
多线程调用 t.start()  子线程调用 run()
```

1、synchronized

```
synchronized 关键字 可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。
JDK1.6 对锁的实现引入了大量的优化，如 自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等来减少锁操作的开销。
线程之间的切换时需要从用户态转换到内核态
synchronized void method() { //业务代码 }//实例方法
synchronized static void method() { //业务代码 }//静态方法
synchronized(this) { //业务代码 }//修饰代码块
synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令 前者开始位置，后者结束位置
synchronized 修饰的方法是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法。
两者的本质都是对对象监视器 monitor 的获取。
```

1、说一下 synchronized 底层实现原理？

```
Synchronized的语义底层是通过一个monitor（监视器锁）的对象来完成，
每个对象有一个监视器锁(monitor)。每个Synchronized修饰过的代码当它的monitor被占用时就 会处于锁定状态并且尝试获取monitor的所有权 ，过程：
1、如果monitor的进入数为0，则该线程进入monitor，然后将进入数设置为1，该线程即为 monitor的所有者。

2、如果线程已经占有该monitor，只是重新进入，则进入monitor的进入数加1.

3、如果其他线程已经占用了monitor，则该线程进入阻塞状态，直到monitor的进入数为0，再 重新尝试获取monitor的所有权。
```

1、synchronized可重入的原理

```
重入锁是指一个线程获取到该锁之后，该线程可以继续获得该锁。底层原理维护一个计数器，当线 程获取该锁时，计数器加一，再次获得该锁时继续加一，释放锁时，计数器减一，当计数器值为0 时，表明该锁未被任何线程所持有，其它线程可以竞争获取锁。
```

1、什么是自旋

```
很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程都加锁 可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然 synchronized 里面的代码执行得非常快，不妨让等待锁的线程不要被阻塞，而是在 synchronized 的边界做忙循环，这就是自旋。如果做了多次循环发现还没有获得锁，再阻塞，这样可能是一种更 好的策略。
忙循环：就是程序员用循环让一个线程等待，不像传统方法wait(), sleep() 或 yield() 它们都放弃了 CPU控制，而忙循环不会放弃CPU，它就是在运行一个空循环。这么做的目的是为了保留CPU缓 存，在多核系统中，一个等待线程醒来的时候可能会在另一个内核运行，这样会重建缓存。为了避 免重建缓存和减少等待重建的时间就可以使用它了。
```

1、Java中synchronized 和 ReentrantLock 有什么不同？（依赖不同、阻塞式同步，关键字，API互斥锁，多了等待可中断、公平锁、锁绑定多个对象）

```
两者都是可重入锁（再次获得自己内部的锁）
等待可中断（正在等待的线程可以选择放弃等待，改为处理其他事情。）
公平锁（现等待的线程优先获得锁）
Lock是显式锁（手动开启和关闭锁，别忘记关闭锁）synchronized是隐式锁，出了 作用域自动释放 
Lock只有代码块锁，synchronized有代码块锁和方法锁 
使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）
优先使用顺序： Lock > 同步代码块（已经进入了方法体，分配了相应资源）> 同步方法（在方法体之外）
```

2、volatile关键字

```
volatile 关键字可以禁止指令进行 重排序优化。
volatile 关键字可以保证共享变量的可见性。
volatile 关键字只能用于变量而 synchronized 关键字可以修饰方法以及代码块
volatile 关键字能保证数据的可见性，但不能保证数据的原子性。
volatile 主要用于解决变量在多个线程之间的可见性， synchronized 解决 多个线程之间访问资源的同步性。
```

2、锁的四种状态、多线程中 synchronized 锁升级的原理是什么？

```
synchronized 锁升级原理：在锁对象的对象头里面有一个 threadid 字段，在第一次访问的时候 threadid 为空，jvm 让其持有偏向锁，并将 threadid 设置为其线程 id，再次进入的时候会先判断 threadid 是否与其线程 id 一致，如果一致则可以直接使用此对象，如果不一致，则升级偏向锁为 轻量级锁，通过自旋循环一定次数来获取锁，执行一定次数之后，如果还没有正常获取到要使用的 对象，此时就会把锁从轻量级升级为重量级锁，此过程就构成了 synchronized 锁的升级。

锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态
注意锁可以升级不可降级为了提 高获得锁和释放锁的效率。

偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访 问，不存在多线程争用的情况，则线程是不需要触发同步的，减少加锁／解锁的一些CAS操作（比 如等待队列的一些CAS操作），这种情况下，就会给线程加一个偏向锁。 如果在运行过程中，遇 到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标 准的轻量级锁。 

轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁 争用的时候，轻量级锁就会升级为重量级锁； 

重量级锁是synchronized ，是 Java 虚拟机中最为基础的锁实现。在这种状态下，Java 虚拟机会阻 塞加锁失败的线程，并且在目标锁被释放的时候，唤醒这些线程。
```



1、线程 B 怎么知道线程 A 修改了变量

```
（1）volatile 修饰变量 
（2）synchronized 修饰修改变量的方法 
（3）wait/notify 
（4）while 轮询
```

1、synchronized、volatile、CAS 比较

```
（1）synchronized 是悲观锁，属于抢占式，会引起其他线程阻塞。 
（2）volatile 提供多线程共享变量可见性和禁止指令重排序优化。 
（3）CAS 是基于冲突检测的乐观锁（非阻塞）
```

1、synchronized 和 Lock 有什么区别？

```
首先synchronized是Java内置关键字，在JVM层面，Lock是个Java类； 
synchronized 可以给类、方法、代码块加锁；而 lock 只能给代码块加锁。 
synchronized 不需要手动获取锁和释放锁，使用简单，发生异常会自动释放锁，不会造成死锁； 而 lock 需要自己加锁和释放锁，如果使用不当没有 unLock()去释放锁就会造成死锁。 
通过 Lock 可以知道有没有成功获取锁，而 synchronized 却无法办到。
```

1、synchronized 和 ReentrantLock 区别是什么？

```
synchronized 是和 if、else、for、while 一样的关键字，ReentrantLock 是类，这是二者的本质 区别。
既然 ReentrantLock 是类，那么它就提供了比synchronized 更多更灵活的特性，可以被继 承、可以有方法、可以有各种各样的类变量 
synchronized 早期的实现比较低效，对比 ReentrantLock，大多数场景性能都相差较大，
但是在 Java 6 中对 synchronized 进行了非常多的改进。 相同点：两者都是可重入锁
主要区别如下：

ReentrantLock 使用起来比较灵活，但是必须有释放锁的配合动作； 
ReentrantLock 必须手动获取与释放锁，而 synchronized 不需要手动释放和开启锁； 
ReentrantLock 只适用于代码块锁，而 synchronized 可以修饰类、方法、变量等。 
二者的锁机制其实也是不一样的。ReentrantLock 底层调用的是 Unsafe 的park 方法加锁，
synchronized 操作的应该是对象头中 mark word
```

1、程序、进程、线程

```
程序是指令和数据的有序集合，其本身没有任何运 行的含义，是一个静态的概念。
进程则是执行程序的一次执行过程，它是一个动态的概念。是系统资源分配的单位
线程是CPU调度和执行的的单位。一个进程中可以包含若干个线程
线程状态：创建状态（new完）、就绪状态（调用Start方法）、阻塞状态（sleep、wait等）、运行状态、死亡状态
```

1、Java中实现多线程的方式（Thread、Runnable、callable、线程池方式创建）

```
1、Runnable和 Callable的区别
1、重写的方法不同 Call（），Run（）
2、C可以返回返回值 、R不可以 
3、C可以抛出异常
4、C可以拿到一个Future对象、表示异步计算结果-检查计算是否完成，检索计算结果，了解任务执行情况，取消任务执行，获取结果
```

2、停止一个正在运行的线程（推出标志、stop、interrupt）

2、Join合并线程，待此线程执行完成后，再执行其他线程，其他线程阻塞

3、notify（）和notifyall（）的区别（死锁）

4、sleep和wait的区别（thread, object 、不会释放对象锁，放弃对象锁等待notify）

5、线程的 sleep()方法和 yield()方法有什么区别？

```
（1） sleep()方法给其他线程运行机会时不考虑线程的优先级，因此会给低优先级的线程以运行的 机会；yield()方法只会给相同优先级或更高优先级的线程以运行的机会； 
（2） 线程执行 sleep()方法后转入阻塞（blocked）状态，而执行 yield()方法后转入就绪 （ready）状态； 
（3）sleep()方法声明抛出 InterruptedException，而 yield()方法没有声明任何异常； 
（4）sleep()方法比 yield()方法（跟操作系统 CPU 调度相关）具有更好的可移植性，通常不建议 使用yield()方法来控制并发线程的执行。
```

4、上下文切换

```
上下文切换。概括来说就是：当 前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次 再切换回这个任务时，可以再加载这个任务的状态。
任务从保存到再加载的过程
```

5、volatile是什么保证有序性（其他线程、立即可见，禁止指令重排序）状态标记量和单例模式双检锁

```
synchronized 关键字和 volatile 关键字的区别？
1、一个只能修饰变量一个修饰方法、代码块
2、多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞
3、volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保 证 
4、volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个 线程之间访问资源的同步性。
```

5、什么是重排序

![image-20220506144149279](/Users/zhangdada/Library/Application Support/typora-user-images/image-20220506144149279.png)

```
一般来说处理器为了提高程序运行效率，可能会对输入代码进行优化，进行重新排序（重排序）， 它不保证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和 代码顺序执行的结果是一致的。
```

6、Thread类中的Start（）和run（）的区别 （是否有新线程启动）

​	调用Start方法可以启动线程使其进入就绪状态，而run方法只是thread的一个普通的方法调用。

7、为什么wait, notify 和 notifyAll这些方法不在thread类里面(Java锁是对象级不是线程级）

8、为什么wait和notify方法要在同步块中调用？（调用线程必须已经得到该对象的锁）

9、Java中interrupted 和 isInterruptedd方法的区别？（前者会将中断状态清除而后者不会）

11、有三个线程T1,T2,T3,如何保证顺序执行？join()方法在一个线程中启动另一 个线程，

12、SynchronizedMap和ConcurrentHashMap有什么区别？（前者，都对整个map进行同步后者它对map中的所有桶加了锁）

13、什么是线程安全（代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么就是线程安全的。）

​		（1）不可变（2）绝对线程安全（3）相对线程安全（4）线程非安全

14、Thread类中的yield方法有什么作用？（Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行）

15、Java线程池中submit() 和 execute()方法有什么区别？（1、返回值Void、计算结果的Future对象2、接口不同）

16、说一说自己对于 synchronized 关键字的了解（修饰的方法或者代码块在任意时刻只能有一个线程执行Java6 jdk1.6优化）

17、说说自己是怎么使用 synchronized 关键字？（修饰实例方法、修饰静态方法）

18、什么是线程安全？Vector是一个线程安全类吗？（同步方法实现线程安全、ArrayList不安全）

19、 volatile关键字的作用？告诉jvm当前变量在寄存器（工作内存）中的值是不确定的，需要从主存中读取

20、常用的线程池有哪些？newSingleThreadExecutor、newFixedThreadPool、newCachedThreadPool、newScheduledThreadPool

21、简述一下你对线程池的理解（资源消耗、响应速度、线程可管理性）

22、Java程序是如何执行的（Java 源代码 -> 词法分析器 -> 语法分析器 -> 语义分析器 -> 字符码生成器 -> 最终生成字节码）

![image-20220324203705159](/Users/zhangdada/Library/Application Support/typora-user-images/image-20220324203705159.png)

23、锁的优化机制了解吗？（无锁->偏向锁->轻量级锁->重量级锁）

自适应锁、自旋锁、锁消除、锁粗化、轻量级锁和偏向锁。

![图片来自 java面试题，第 67 页](/Users/zhangdada/Desktop/图片来自 java面试题，第 67 页.png)

24、说说进程和线程的区别？是系统进行资源分配和调度的一个独立单位

25，产生死锁的四个必要条件？互斥条件：请求与保持条件：不剥夺条件：循环等待条件：

26、如何避免死锁？获得锁的顺序是一定的

27、线程池核心线程数怎么设置呢？分为CPU密集型：CPU核心数量*2，IO密集型：N（CPU 核心数）+1、

28，Java线程池中队列常用类型有哪些？

```bash
ArrayBlockingQueue有界阻塞队列
LinkedBlockingQueue阻塞队列
SynchronousQueue 不存储元素的阻塞队列
PriorityBlockingQueue一个具有优先级的无限阻塞队列。
PriorityBlockingQueue也是基于最小二叉堆实现
DelayQueue只有当其指定的延迟时间到了，才能够从队列中获取到该元素。
```

29、线程安全需要保证几个基本特征？原子性-不被干扰、可见性-其他线程知道、有序性-避免指令重排。

30、说一下线程之间是如何通信的？共享内存（主内存）和消息传递（wait\notify\blockingqueue）。

31、CAS的原理呢？比较交换V（变量内存地址）A（旧值）B（新值）

32、CAS有什么缺点吗？ABA问题、循环时间长开销大、保证一个共享变量的原子操作

```
1、ABA 问题：

比如说一个线程 one 从内存位置 V 中取出 A，这时候另一个线程 two 也从内存中取出 A，并且 two 进 行了一些操作变成了 B，然后 two 又将 V 位置的数据变成 A，这时候线程 one 进行 CAS 操作发现内存 中仍然是 A，然后 one 操作成功。尽管线程 one 的 CAS 操作成功，但可能存在潜藏的问题。从 Java1.5 开始 JDK 的 atomic包里提供了一个类 AtomicStampedReference 来解决 ABA 问题。
2、循环时间长开销大：

对于资源竞争严重（线程冲突严重）的情况，CAS 自旋的概率会比较大，从而浪费更多的 CPU 资源， 效率低于 synchronized。
3、只能保证一个共享变量的原子操作：

当对一个共享变量执行操作时，我们可以使用循环 CAS 的方式来保证原子操作，但是对多个共享变量 操作时，循环 CAS 就无法保证操作的原子性，这个时候就可以用锁。
```

33、引用类型有哪些？有什么区别？强引用、软引用、弱引用、虚引用

34、说说ThreadLocal原理？线程本地变量在每个线程都创建一个副本

35、线程池原理知道吗？以及核心参数（满、阻塞队列、继续创建、自动销毁、拒绝策略） 

```bash
1. 最大线程数maximumPoolSize
2. 核心线程数corePoolSize
3. 活跃时间keepAliveTime
4. 阻塞队列workQueue
5. 拒绝策略RejectedExecutionHandler
```

36、 线程池的拒绝策略有哪些？

```bash
1. AbortPolicy：直接丢弃任务，抛出异常，这是默认策略
2. CallerRunsPolicy：只用调用者所在的线程来处理任务
3. DiscardOldestPolicy：丢弃等待队列中最旧的任务，并执行当前任务
4. DiscardPolicy：直接丢弃任务，也不抛出异常
```

37、说说你对JMM内存模型的理解？为什么需要JMM？CPU的速度远快于内存（缓存）

```
共享内存模型指的就是Java内存模型 java内存模型简称jmm，定义了一个线程对另一个线程可见。共享变 量存放在主内存中，每个线程都有自己的本地内存，当多个线程同时访问一个数据的时候，可能本 地内存没有及时刷新到主内存，所以就会发生线程安全问题。
从抽象的角度来看，JMM定义了线程和主内存之间的抽象关系：线程之间的共享变 量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本 地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存 在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。
```

38、多线程有什么用？（多核优势、防止阻塞、便于建模）

39、说说CyclicBarrier和CountDownLatch的区别？（代码运行到某一点：是否停止、唤起一个多个 任务、是否重用）

40、什么是AQS？AbstractQueuedSychronizer 核心tryLock和tryRelease

```
AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大 量的同步器，比如我们提到的 ReentrantLock ， Semaphore ，其他的诸如 ReentrantReadWriteLock ， SynchronousQueue ， FutureTask 等等皆是基于 AQS 的。
```

41、了解Semaphore吗？信号量，它的作用是限制某段代码块的并发数

42、什么是Callable和Future?产生结果、获取结果

43、什么是阻塞队列？阻塞队列的实现原理是什么？如何使用阻 塞队列来实现生产者-消费者模型？（支持两个附加操作的队列）

44、什么是多线程中的上下文切换？（CPU会停止处理当前运行的程序，存储和恢复CPU状态的过程）

45、什么是Daemon线程？它有什么意义？（比如：JVM的垃圾回收线程就是Daemon线程，Finalizer也是守护线程。）

```
虚拟机必须确保用户线程执行完毕
虚拟机不用等待守护线程执行完毕
如,后台记录操作日志,监控内存,垃圾回收等待..
```

46、乐观锁和悲观锁的理解及如何实现，有哪些实现方式？

47、常用并发列队的介绍

```
1.非堵塞队列：ArrayDeque, （数组双端队列）
	ArrayDeque （非堵塞队列）是JDK容器中的一个双端队列实现，内部使用数组进行元素存 储，不允许存储null值，可以高效的进行元素查找和尾部插入取出，是用作队列、双端队 列、栈的绝佳选择，性能比LinkedList还要好。
2. PriorityQueue, （优先级队列）
	PriorityQueue （非堵塞队列） 一个基于优先级的无界优先级队列。优先级队列的元素按照其自 然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造 方法。该队列不允许使用 null 元素也不允许插入不可比较的对象
3. ConcurrentLinkedQueue, （基于链表的并发队列）
	ConcurrentLinkedQueue （非堵塞队列）: 是一个适用于高并发场景下的队列，通过无锁的方 式，实现了高并发状态下的高性能。ConcurrentLinkedQueue的性能要好于BlockingQueue接 口，它是一个基于链接节点的无界线程安全队列。该队列的元素遵循先进先出的原则。该队列不允 许null元素。
4. 堵塞队列： 1. DelayQueue, （基于时间优先级的队列，延期阻塞队列）
	DelayQueue是一个没有边界BlockingQueue实现，加入其中的元素必需实现Delayed接口。 当生产者线程调用put之类的方法加入元素时，会触发Delayed接口中的compareTo方法进行 排序，也就是说队列中元素的顺序是按到期时间排序的，而非它们进入队列的顺序。排在队 列头部的元素是最早到期的，越往后到期时间赿晚
5. ArrayBlockingQueue, （基于数组的并发阻塞队列）
	ArrayBlockingQueue是一个有边界的阻塞队列，它的内部实现是一个数组。有边界的意思是它 的容量是有限的，我们必须在其初始化的时候指定它的容量大小，容量大小一旦指定就不可改变。 ArrayBlockingQueue是以先进先出的方式存储数据
6. LinkedBlockingQueue, （基于链表的FIFO阻塞队列）
	LinkedBlockingQueue阻塞队列大小的配置是可选的，如果我们初始化时指定一个大小，它就是 有边界的，如果不指定，它就是无边界的。说是无边界，其实是采用了默认大小为 Integer.MAX_VALUE的容量 。它的内部实现是一个链表。
7. LinkedBlockingDeque, （基于链表的FIFO双端阻塞队列）
	LinkedBlockingDeque是一个由链表结构组成的双向阻塞队列，即可以从队列的两端插入和移除 元素。双向队列因为多了一个操作队列的入口，在多线程同时入队时，也就减少了一半的竞争。
```



# Spring篇

1、什么是spring?

2、你们项目中为什么使用Spring框架？轻量、控制反转、AOP、容器、MVC框架、事务管理、异常处理

3、 Autowired和Resource关键字的区别？做bean的注入，后者不是Spring的注解。前者Bytype和@Qualifier变成byname，后者byname（用于字段，属性的方法上）

4、依赖注入的方式有几种，各是什么?（构造器注入（初始化后、长）、setter方法注入（选择、初始化）、接口注入（简单、侵入性））

5、讲一下什么是Spring

```bash
Spring Core：核心类库，提供IOC服务； 
Spring Context：提供框架式的Bean访问方式，以及企业级功能（JNDI、定时任务等）； 
Spring AOP：AOP服务； 
Spring DAO：对JDBC的抽象，简化了数据访问异常的处理； 
Spring ORM：对现有的ORM框架的支持； 
Spring Web：提供了基本的面向Web的综合特性，例如多方文件上传； 
Spring MVC：提供面向Web应用的Model-View-Controller实现。
```

spring mvc的使用流程 

```
第一步：发起请求到前端控制器(DispatcherServlet)
第二步：前端控制器请求HandlerMapping查找 Handler可以根据xml配置、注解进行查找
第三步：处理器映射器HandlerMapping向前端控制器返回Handler
第四步：前端控制器调用处理器适配器去执行Handler
第五步：处理器适配器去执行Handler
第六步：Handler执行完成给适配器返回ModelAndView
第七步：处理器适配器向前端控制器返回ModelAndView ModelAndView是springmvc框架的一个底层对象，包括Model和view
第八步：前端控制器请求视图解析器去进行视图解析 根据逻辑视图名解析成真正的视图(jsp)
第九步：视图解析器向前端控制器返回View
第十步：前端控制器进行视图渲染视图渲染将模型数据(在ModelAndView对象中)填充到request域
第十一步：前端控制器向用户响应结果
```

6、说说你对Spring MVC的理解（设计模式）

```bash
M-Model 模型（完成业务逻辑：有javaBean构成，service+dao+entity） 
V-View 视图（做界面的展示 jsp，html……） 
C-Controller 控制器（接收请求—>调用模型—>根据结果派发页面）
```

7、 SpringMVC常用的注解有哪些？

```bash
@RequestMapping：用于处理请求 url 映射的注解，可用于类或方法上。用于类上，则表示类中 的所有响应请求的方法都是以该地址作为父路径。
@RequestBody：注解实现接收http请求的json数据，将json转换为java对象。
@ResponseBody：注解实现将conreoller方法返回对象转化为json对象响应给客户。
```

7、谈谈⾃⼰对于 Spring IoC 的理解

```
是⼀种设计思想，就是 将原本在程序中⼿动创建对象的控制 权，交由Spring框架来管理。DI(依赖注入)是实现IoC的一种方法
IoC 容器是Spring⽤来实现IoC的载体，IoC容器实际上就是个Map（key，value）,Map 中存放的是各种对象。
IoC 容器就像是⼀个工厂一样，当我们需要创建⼀个对象的时候，只需要配置好配置⽂件/注解即可

Spring 时代我们⼀般通过 XML ⽂件来配置 Bean
SpringBoot 注解配置就慢慢开始流⾏起来。
```

8、 谈谈你对Spring的AOP理解（事务处理、日志管理、权限控制封装起来）

```
与业务无关，却为业务模块所 共同调用的逻辑或责任于，
减少系统的重复代码，降低模块间的耦合度，并有利于未来的可扩展性和可维护性。
Spring AOP是基于动态代理的，如果要代理的对象实现了某个接口，那么Spring AOP就会使用JDK动态代理（JDK Proxy）去创建代理对象；而对于没有实现接口的对象，就无法使用JDK动态代理，转而使用CGlib 动态代理生成一个被代理对象的子类来作为代理。
AspectJ应该算得上是Java生态系统中 最完整的AOP框架了。
```

9、Spring AOP和AspectJ AOP有什么区别？

```
Spring AOP是属于运行时增强，而AspectJ是编译时增强。
Spring AOP基于代理（Proxying），而 AspectJ基于字节码操作（Bytecode Manipulation）。
切面比较少差距不大、切面多AspectJ
```

在Spring AOP 中，关注点和横切关注的区别是什么？

```
关注点是应用中一个模块的行为，一个关注点可能会被定义成一个我们想实现的一个功能。
横切关 注点是一个关注点，此关注点是整个应用都会使用的功能，
连接点代表一个应用程序的某个位置，
切入点是一个或一组连接点，通知将在这些位置执行。
```

什么是通知呢？有哪些类型呢？

通知是个在方法执行前或执行后要做的动作，实际上是程序执行时要通过SpringAOP框架触发的代码段。

```
Spring切面可以应用五种类型的通知：
before：前置通知，在一个方法执行前被调用。 
after: 在方法执行之后调用的通知，无论方法执行是否成功。 
after-returning: 仅当方法成功完成后执行的通知。 
after-throwing: 在方法抛出异常退出时执行的通知。 
around: 在方法执行之前和之后调用的通知。
```

10、说说你对Spring的IOC是怎么理解的？

```
控制反转，创建对象由自己转成Spring容器
容器根据配置文件去创建实例和管理各个实例之间的依赖关系     
DI依赖注入：应用程序在运行时依赖IoC容器来动态注入对象需要的外部资源。
三种注入方式 ：构造器注入、setter方法注入、根据注解注入。
```

11、IOC的初始化过程

![image-20220505160752281](/Users/zhangdada/Library/Application Support/typora-user-images/image-20220505160752281.png)

11、解释一下spring bean的生命周期

![image-20220505160952514](/Users/zhangdada/Library/Application Support/typora-user-images/image-20220505160952514.png)

```
Servlet的生命周期：实例化，初始init，接收请求service，销毁destroy；
（1）实例化Bean：（2）设置对象属性（依赖注入）：（3）处理Aware接口：（4）BeanPostProcessor：
（5）InitializingBean 与 init-method：（7）DisposableBean：（8）destroy-method：
```

![image-20220325134444783](/Users/zhangdada/Library/Application Support/typora-user-images/image-20220325134444783.png)

12、解释Spring支持的几种bean的作用域？（5）

```
（1）singleton：默认，每个容器中只有一个bean的实例，单例的模式由BeanFactory自身来维护。
（2）prototype：为每一个bean请求提供一个实例。
（3）request：为每一个网络请求创建一个实例，在请求完成以后，bean会失效并被垃圾回收器回收。
（4）session：与request范围类似，确保每个session中有一个bean的实例，在session过期后， bean会随之失效。
（5）global-session：全局作用域，global-session和Portlet应用相关。当你的应用部署在Portlet 容器中工作时，它包含很多portlet。如果你想要声明让所有的portlet共用全局的存储变量的话，那 么这全局变量需要存储在global-session中。全局作用域与Servlet中的session作用域效果相同。
```

12、Bean的自动装配

```
自动装配是使用spring满足bean依赖的一种方法 spring会在应用上下文中为某个bean寻找其依赖的bean。
Spring中bean有三种装配机制，分别是：

1. 在xml中显式配置；

2. 在java中显式配置；

3. 隐式的bean发现机制和自动装配。
Spring的自动装配
1. 组件扫描(component scanning)：spring会自动发现应用上下文中所创建的bean；

2. 自动装配(autowiring)：spring自动满足bean之间的依赖，也就是我们说的IoC/DI；
```

12、@Component 和 @Bean 的区别是什么？

```
1. 作⽤对象不同: @Component 注解作⽤于类，⽽ @Bean 注解作⽤于⽅法。
2. @Component 通常是通过类路径扫描来⾃动侦测以及⾃动装配到Spring容器中（我们可以使 ⽤ @ComponentScan 注解定义要扫描的路径从中找出标识了需要装配的类⾃动装配到 Spring 的 bean 容器中）。 @Bean 注解通常是我们在标有该注解的⽅法中定义产⽣这个 bean, @Bean 告诉了Spring这是某个类的示例，当我需要⽤它的时候还给我。
3. @Bean 注解⽐ Component 注解的⾃定义性更强，⽽且很多地⽅我们只能通过 @Bean 注 解来注册bean。⽐如当我们引⽤第三⽅库中的类需要装配到 Spring 容器时，则只能通过 @Bean 来实现。
```

13、将⼀个类声明为Spring的 bean 的注解有哪些?

```
我们⼀般使⽤ @Autowired 注解⾃动装配 bean，要想把类标识成可⽤于 @Autowired 注解⾃动装配的 bean 的类,采⽤以下注解可实现：
@Component ：通⽤的注解，可标注任意类为 个层，可以使⽤ @Component 注解标注。
@Repository : 对应持久层即 Dao 层，主要⽤于数据库相关操作。 
@Service : 对应服务层，主要涉及⼀些复杂的逻辑，需要⽤到 Dao层。
@Controller : 对应 Spring MVC 控制层，主要⽤户接受⽤户请求并调⽤ Service 层返回数 据给前端⻚⾯。
```

13、 Spring基于xml注入bean的几种方式?（1）Set方法注入；（2）构造器注入：（3）静态工厂注入；（4）实例工厂；

14、 beanFactory和factoryBean有什么区别

```
1、相同点：都是用来创建bean对象
2、不同点：使用beanFactory 创建对象的时候必须严格遵循生命周期流程
要想简单的自定义某个对象的创建同时交给Spring管理，需要实现FactoryBean接口
```

14、Spring框架中都用到了哪些设计模式？

```
简单工厂模式：BeanFactory 根据传入一个唯一的标识来获 得 Bean 对象，但是在传入参数后创建还是传入参数前创建不确定
工厂模式：FactoryBean，getBean()—bean—getObject()返回值；bean.getOjbect()
单例模式：scope="singleton"，bean 存放于 Map 中。bean name 当做 key，bean 当做 value。
原型模式：scope="prototype" 通过克隆生成的新实例，修改时对原有实例对象不造成任何影响。
迭代器模式：在 Spring 中有个 CompositeIterator 实现了 Iterator，
代理模式：AOP 动态代理实现的，分 JDK 和 CGlib 动态代理。
适配器模式：AdvisorAdapter 类，三个实现：MethodBeforAdviceAdapter、AfterReturnningAdviceAdapter、ThrowsAdviceAdapter。
观察者模式：Spring 中的 Event 和 Listener
模板模式：Spring 中 org.springframework.jdbc.core.JdbcTemplate里面的 execute 方法，整个算法步骤都定义好
责任链模式：DispatcherServlet 中的 doDispatch() 方法中获取与请求匹配的处理器 HandlerExecutionChain，this.getHandler() 方法的处理使用到了责任链模式。
```

15、说说Spring 中 ApplicationContext 和 BeanFactory 的区别

```
包目录、
国际化、ApplicationContext 扩展了 MessageResource 接口
事件机制、ApplicationContext 的事件机制 主要通过 ApplicationEvent 和 ApplicationListener 两个接口
底层资源的访问、ApplicationContext 扩展了 ResourceLoader（资源加载器）接口，
对Web应用的支持、与BeanFactory 通常以编程的方式被创建，ApplicationContext 能以声明的方式创建
延迟加载、BeanFactory 需要手动注册，而 ApplicationContext 则是自动注册。
常用容器、XmlBeanFactory，ClassPathXmlApplicationContext：FileSystemXmlApplicationContext：XmlWebApplicationContext
```

16、Spring 框架中的单例 Bean 是线程安全的么？（将多态 Bean 的作用域（Scope）由 Singleton 变更为 Prototype。）

```
controller、service、dao这些ben是无状态的，不能保存数据
1. 在Bean对象中尽量避免定义可变的成员变量（不太现实）。
2. 在类中定义⼀个ThreadLocal成员变量，将需要的可变成员变量保存在 ThreadLocal 中（推 荐的⼀种⽅式）。
```

17、Spring 是怎么解决循环依赖的？三级缓存，提前曝光。

![image-20220325144005984](/Users/zhangdada/Library/Application Support/typora-user-images/image-20220325144005984.png)

17、Spring 事务

```
Spring 管理事务的⽅式有⼏种？
1. 编程式事务，在代码中硬编码。(不推荐使⽤)
2. 声明式事务，在配置⽂件中配置（推荐使⽤）
声明式事务⼜分为两种：
1. 基于XML的声明式事务
2. 基于注解的声明式事务

spring七个事务传播属性：
• 1.PROPAGATION_REQUIRED – 支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。
• 2.PROPAGATION_SUPPORTS – 支持当前事务，如果当前没有事务，就以非事务方式执行。
• 3.PROPAGATION_MANDATORY – 支持当前事务，如果当前没有事务，就抛出异常。
• 4.PROPAGATION_REQUIRES_NEW – 新建事务，如果当前存在事务，把当前事务挂起。
• 5.PROPAGATION_NOT_SUPPORTED – 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。
• 6.PROPAGATION_NEVER – 以非事务方式执行，如果当前存在事务，则抛出异常。
• 7.PROPAGATION_NESTED – 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则进行与PROPAGATION_REQUIRED类似的操作。
```

18、说说事务的隔离级别

```
未提交读：允许脏读，也就是可能读取到其他会话中未提交事务修改的数据
提交读：只能读取到已经提交的数据。
可重复读：在同一个事务内的查询都是事务开始时刻一致的，Mysql的InnoDB默 认级别。
幻读：多个事务同时修改同一条记录，事务之间不知道彼此存在，当事务提交之后，后面的事务修改的数据将会覆盖前事务，前 一个事务就像发生幻觉一样
可串行化：完全串行化的读，每次读都需要获得表级共享锁，读写相互都会阻塞。

不可重复读和幻读的区别主要是：解决不可重复读需要锁定了当前满足条件的记录，而解决幻读需 要锁定当前满足条件的记录及相近的记录。比如查询某个商品的信息，可重复读事务隔离级别可以 保证当前商品信息被锁定，解决不可重复读；但是如果统计商品个数，中途有记录插入，可重复读 事务隔离级别就不能保证两个事务统计的个数相同。
```

19、说说事务的传播级别

```
1. PROPAGATION_REQUIRED:默认的Spring事物传播级别，若当前存在事务，则加入该事务，若不存在事务，则新建一个事务。
2. PAOPAGATION_REQUIRE_NEW:若当前没有事务，则新建一个事务。若当前存在事务，则新建 一个事务，新老事务相互独立。外部事务抛出异常回滚不会影响内部事务的正常提交。
3. PROPAGATION_NESTED:如果当前存在事务，则嵌套在当前事务中执行。如果当前没有事务， 则新建一个事务，类似于REQUIRE_NEW。
4. PROPAGATION_SUPPORTS:支持当前事务，若当前不存在事务，以非事务的方式执行。
5. PROPAGATION_NOT_SUPPORTED:以非事务的方式执行，若当前存在事务，则把当前事务挂 起。
6. PROPAGATION_MANDATORY:强制事务执行，若当前不存在事务，则抛出异常.
7. PROPAGATION_NEVER:以非事务的方式执行，如果当前存在事务，则抛出异常。
Spring事务传播级别一般不需要定义，默认就是PROPAGATION_REQUIRED，除非在嵌套事务的情 况下需要重点了解。
```

20、Spring 事务实现方式（编程式事务管理：编程，声明式事务管理：XML或者注解）

21、 Spring框架的事务管理有哪些优点

```
它为不同的事务API(如JTA, JDBC, Hibernate, JPA, 和JDO)提供了统一的编程模型。
它为编程式事务 管理提供了一个简单的API而非一系列复杂的事务API(如JTA).它支持声明式事务管理。它可以和 Spring 的多种数据访问技术很好的融合。
```

22、事务三要素是什么？数据源：Mysql 事务管理器：打开、提交、回滚、事务应用和属性配置:

23、 事务注解的本质是什么？@Transactional 这个注解仅仅是一些（和事务相关的）元数据

```
一是表明该方法要参与事务，二是配置相关属性来定制事务的参与方式和运行行为
```

24、 Spring是怎么解决循环依赖的？

```
构造器的循环依赖：这种依赖spring是处理不了的，直接抛出BeanCurrentlylnCreationException异常。
单例模式下的setter循环依赖：通过“三级缓存”处理循环依赖。
非单例循环依赖：无法处理。
```

25、JDK动态代理和CGLIB有什么区别？

```
JDK：这是Java提供的动态代理技术，可以在运行时创建接口的代理实例。Spring AOP默认采用这种方式，在接口的代理实例中织入代码。
CGLIB：采用底层的字节码技术，在运行时创建子类代理的实例。当目标对象不存在接口时，Spring AOP就会采用这种方式，在子类实例中织入代码。

在性能方面，CGLib创建的代理对象比JDK动态代理创建的代理对象高很多。但是，CGLib在创建代理对象时所花费的时间比JDK动态代理多很多。所以，对于单例的对象因为无需频繁创建代理对象，采用CGLib动态代理比较合适。反之，对于多例的对象因为需要频繁的创建代理对象，则JDK动态代理更合适。
```



# MyBatis篇

Object relationship Mapping --> 对象关系映射

1、Mybatis为什么出现？为什么不是直接使用jdbc？

```
因为MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。
```

1、用java语言,说一下数据库的连接和使用

```
1、编写JDBC驱动有了驱动就可以与数据库打开一个通信通道（DriverManager 类）
2、打开连接：需要使用DriverManager.getConnection()方法创建一个Connection对象，它代表与数据库的物理连接
（java.sql.Preparedstatement 接口）
3、执行查询：需要使用类型声明的对象建立并提交一个SQL语句到数据库
4、从结果集中提取数据：要求使用适当的关于ResultSet.getXXX()方法来检索结果集的数据
5、处理结果集：对得到的结果集进行相关的操作（java.sql.Resuiltset 接口）
6、清理环境：需要明确地关闭所有的数据库资源，释放内存

```

2、JDBC连接数据库步骤(六个步骤)

```
1.注册驱动：Class.forName("com.mysql.jdbc.Driver");//显示的加载到JVM中
2.获取连接：
要连接数据库的url---- String url="jdbc:mysql://localhost:3306/test?"+ "useUnicode=true&characterEncoding=UTF8";//防止乱码
要连接数据库的用户名---- String user="xxxx";
要连接数据库的密码---- String pass="xxxx";

//DriverManager下的方法：getConnection(String url,String username,String password)
Connection conn=DriverManager.getConnection(url,user,pass)；

3.创建一个Statement语句对象
//Connection接口下的方法：Statement createStatement()
Statement stmt=conn.createStatement();

PreparedStatement pstmt = conn.PreparedStatement() ;

CallableStatement cstmt =  conn.prepareCall("{CALL demoSp(? , ?)}") ;

4.执行SQL语句:
executeUpdate();

ResultSet rs=stmt.executeQuery(Sql);
5.处理结果集：
6.关闭资源：
```

1、什么是MyBatis（一个半ORM（对象关系映射）框架封装了JDBC主需要关注SQL本身，用 XML 或注解来配置和映射原生信息）

2、说说MyBatis的优点和缺点

3、#{}和${}的区别是什么？

```
#{}是预编译处理，${}是字符串替换。
处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值； 
处理${}时，就是把${}替换成变量的值。 
使用#{}可以有效的防止SQL注入，提高系统安全性。
```

4、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？（1、别名2、映射）

5、Mybatis是如何进行分页的？分页插件的原理是什么？

```
1）Mybatis 使用 RowBounds 对象进行分页，也可以直接编写 sql 实现分页，也可以使用 Mybatis 的分页插件。

2）分页插件的原理：实现 Mybatis 提供的接口，实现自定义插件，在插件的拦截方法内拦 截待执行的 sql，然后重写 sql。
select * from student，拦截 sql 后重写为：select t.* from （select * from student）t limit 0，10
```

6、Mybatis是如何将sql执行结果封装为目标对象并返回的？都有 哪些映射形式？（便签、别名、反射创建对象）

7、 如何执行批量插入？

```
for (string name : names) {
mapper.insertname(name); }
```

8、Xml映射文件中，除了常见的select|insert|updae|delete 标签之外，还有哪些标签？

```
<resultMap> 、 <parameterMap> 、 <sql> 、 <include> 、 <selectKey> ，加上动态 sql 的 9 个标签，trim|where|set|foreach|if|choose|when|otherwise|bind 等，其中为 sql 片段标签，通 过 <include> 标签引入 sql 片段， <selectKey> 为不支持自增的主键生成策略标签。
```

9、MyBatis实现一对一有几种方式?具体怎么操作的？

```
联合查询是几个表联合查询,只查询一次, 通过在resultMap里面配置 association节点配置一对一的类就可以完成；
嵌套查询是先查一个表，根据这个表里面的结果的 外键id，去再另外一个表里面查询数据,也是通过 association配置，但另外一个表的查询通过select属性配置。
```

10、Mybatis是否支持延迟加载？如果支持，它的实现原理是什 么？

```
Mybatis仅支持association关联对象和collection关联集合对象的延迟加载，
association指的就是一 对一，collection指的就是一对多查询。
它的原理是，使用CGLIB创建目标对象的代理对象，当调用目标方法时，进入拦截器方法，比如调 用a.getB().getName()，拦截器invoke()方法发现a.getB()是null值，那么就会单独发送事先保存好的 查询关联B对象的sql，把B查询上来，然后调用a.setB(b)，于是a的对象b属性就有值了，接着完成 a.getB().getName()方法的调用。这就是延迟加载的基本原理。
```

11、Mybatis 能执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区 别？

```
能，Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的 关联查询，多对一查询，其实就是一对一查询，只需要把 selectOne()修改为 selectList()即可；多对多查询，其实就是一对多查询，只需要把 selectOne()修改为 selectList()即可。
关联对象查询，有两种实现方式，一种是单独发送一个 sql 去查询关联对象，赋给主对 象，然后返回主对象。另一种是使用嵌套查询，嵌套查询的含义为使用 join 查询，一部分 列是 A 对象的属性值，另外一部分列是关联对象 B 的属性值，好处是只发一个 sql 查询， 就可以把主对象和其关联对象查出来。
```

11、说说Mybatis的缓存机制

```
一级缓存localCache优化 相同的 SQL 语句，，有多个 SqlSession 或者分布式的环境下，引起脏数据建议,设定缓存级别为 Statement。
二级缓存多个 SqlSession 之间需要共享缓存
```

12、为什么说 Mybatis 是半自动 ORM 映射工具？它与全自动的区别在哪里？

```
Hibernate 属于全自动 ORM 映射工具，使用 Hibernate 查询关联对象或者关联集合对象 时，可以根据对象关系模型直接获取，所以它是全自动的。而 Mybatis 在查询关联对象或 关联集合对象时，需要手动编写 sql 来完成，所以，称之为半自动 ORM 映射工具。
```

12、JDBC 编程有哪些步骤？

```
1.装载相应的数据库的 JDBC 驱动并进行初始化：Class.forName("com.mysql.jdbc.Driver");
2.建立 JDBC 和数据库之间的 Connection 连接：
Connection c = DriverManager.getConnection("jdbc:mysql://127.0.0.1:3306/test? characterEncoding=UTF-8", "root", "123456");
3.创建 Statement 或者 PreparedStatement 接口，执行 SQL 语句。
4.处理和显示结果。
5.释放资源。
```

13、MyBatis 中见过什么设计模式？

![image-20220325162646266](/Users/zhangdada/Library/Application Support/typora-user-images/image-20220325162646266.png)

14、MyBatis 中比如 UserMapper.java 是接口，为什么没有实 现类还能调用？

```
使用JDK动态代理+MapperProxy。本质上调用的是MapperProxy的invoke方法。
```

15、Mybatis 是否⽀持延迟加载？如果⽀持，它的实现原理是什么？

```
Mybatis 仅⽀持 association 关联对象和 collection 关联集合对象的延迟加载，association 指 的就是⼀对⼀，collection 指的就是⼀对多查询。在 Mybatis 配置⽂件中，可以配置是否启⽤延 迟加载 lazyLoadingEnabled=true|false

它的原理是，使⽤ CGLIB 创建⽬标对象的代理对象，当调⽤⽬标⽅法时，进⼊拦截器⽅法，⽐ 如调⽤ a.getB().getName() ，拦截器 invoke() ⽅法发现 a.getB() 是 null 值，那么就会单独发送事 先保存好的查询关联 B 对象的 sql，把 B 查询上来，然后调⽤ a.setB(b)，于是 a 的对象 b 属性 就有值了，接着完成 a.getB().getName() ⽅法的调⽤。这就是延迟加载的基本原理。
```

16、Mybatis 的 Xml 映射⽂件中，不同的 Xml 映射⽂件，id 是否可以重复？

```
答：不同的 Xml 映射⽂件，如果配置了 namespace，那么 id 可以重复；如果没有配置 namespace，那么 id 不能重复；毕竟 namespace 不是必须的，只是最佳实践⽽已。

原因就是 namespace+id 是作为 Map<String, MappedStatement> 的 key 使⽤的，如果没有 namespace，就剩下 id，那么，id 重复会导致数据互相覆盖。有了 namespace，⾃然 id 就可以 重复，namespace 不同，namespace+id ⾃然也就不同。
```

17、Mybatis 中如何执⾏批处理？使⽤ BatchExecutor 完成批处理。

18、Mybatis 都有哪些 Executor 执⾏器？它们之间的区别是什么？

```
SimpleExecutor 、 ReuseExecutor 、 BatchExecutor 。
1、SimpleExecutor ：每执⾏⼀次 update 或 select，就开启⼀个 Statement 对象，⽤完⽴刻关闭 Statement 对象。
2、ReuseExecutor ：执⾏ update 或 select，以 sql 作为 key 查找 Statement 对象，存在就使⽤， 不存在就创建，⽤完后，不关闭 Statement 对象，⽽是放置于 Map<String, Statement>内，供下 ⼀次使⽤。简⾔之，就是重复使⽤ Statement 对象。
3、BatchExecutor ：执⾏ update（没有 select，JDBC 批处理不⽀持 select），将所有 sql 都添加 到批处理中（addBatch()），等待统⼀执⾏（executeBatch()），它缓存了多个 Statement 对 象，每个 Statement 对象都是 addBatch()完毕后，等待逐⼀执⾏ executeBatch()批处理。与 JDBC 批处理相同。
```

19、Mybatis 是否可以映射 Enum 枚举类？

```
Mybatis 可以映射枚举类，不单可以映射枚举类，Mybatis 可以映射任何对象到表的⼀列 上。映射⽅式为⾃定义⼀个 TypeHandler ，实现 TypeHandler 的 setParameter() 和 getResult() 接⼝⽅法。 TypeHandler 有两个作⽤，⼀是完成从 javaType ⾄ jdbcType 的转换，⼆是完成 jdbcType ⾄ javaType 的转换，体现为 setParameter() 和 getResult() 两个⽅法，分别代表设置 sql 问号占位符参数和获取列查询结果。
```

20、mybatis 中如何传递多个参数

```
1、顺序传参法
#{}里面的数字代表你传入参数的顺序。
这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错
方法2：@Param注解传参法
#{}里面的名称对应的是注解 @Param括号里面修饰的名称。
这种方法在参数不多的情况还是比较直观的，推荐使用。
方法3：Map传参法
#{}里面的名称对应的是 Map里面的key名称。
这种方法适合传递多个参数，且参数易变能灵活传递的情况。
方法4：Java Bean传参法
#{}里面的名称对应的是 User类里面的成员属性。
这种方法很直观，但需要建一个实体类，扩展不容易，需要加属性，看情况使用。
```



# SpringBoot篇

1、为什么要用SpringBoot

```
一、独立运行-内嵌了各种servlet容器，Tomcat、Jetty
二、简化配置-spring-boot-starter-web启动器自动依赖其他组件，简少了maven的配置
三、自动配置-Spring Boot能根据当前类路径下的类、jar包来自动配置bean
四、无代码生成和XML配置-无需XML配置文件借助于条件注解完成的
```

2、Spring Boot 的核心注解是哪个？它主要由哪几个注解组成 的？

```
启动类上面的注解是@SpringBootApplication
@SpringBootConﬁguration：组合了 @Conﬁguration 注解，实现配置文件的功能。 
@EnableAutoConﬁguration：打开自动配置的功能，也可以关闭某个自动配置的选项，
@SpringBootApplication(exclude = { DataSourceAutoConﬁguration.class } 关闭数据源自动配置功能
@ComponentScan：Spring组件扫描。
```

3、运行Spring Boot有哪几种方式？

```
1）打包用命令或者放到容器中运行 2）用 Maven/Gradle 插件运行 3）直接执行 main 方法运行
```

4、如何理解 Spring Boot 中的 Starters？

5、 如何在Spring Boot启动的时候运行一些特定的代码？

```
实现接口ApplicationRunner或 者CommandLineRunner
```

6、 Spring Boot 需要独立的容器运行吗？

```
可以不需要，内置了 Tomcat/ Jetty 等容器。
```

7、 Spring Boot中的监视器是什么？

```
Spring boot actuator是spring启动框架中的重要功能之一。
```

8、 如何使用Spring Boot实现异常处理？

```
ControlerAdvice类，来处理控制器类抛出的所有异常。
```

9、 你如何理解 Spring Boot 中的 Starters？

```
Starters可以理解为启动器，一系列可以集成到应用里面的依赖包，可以一站式集成Spring及其他技术，而不需要到处找示例代码和依赖包。
如你想使用 Spring JPA 访问数据库，只要 加入 spring-boot-starter-data-jpa 启动器依赖就能使用了
```

10、 springboot常用的starter有哪些

```
spring-boot-starter-web 嵌入tomcat和web开发需要servlet与jsp支持 
spring-boot-starter-data-jpa 数据库支持 
spring-boot-starter-data-redis redis数据库支持 
spring-boot-starter-data-solr solr支持 
mybatis-spring-boot-starter 第三方的mybatis集成starter
```

11、 SpringBoot 实现热部署有哪几种方式？（Spring Loaded和 Spring-boot-devtools）

12、 如何理解 Spring Boot 配置加载顺序？

```
1）properties文件； 2）YAML文件；3）系统环境变量； 4）命令行参数；
```

13、 Spring Boot 的核心配置文件有哪几个？它们的区别是什么？

```
application 和 bootstrap 配置文件。
application 配置文件这个容易理解，主要用于 Spring Boot 项目的自动化配置。
bootstrap 配置文件有以下几个应用场景。
使用 Spring Cloud Conﬁg 配置中心时，这时需要在 bootstrap 配置文件中添加连接到配置中心的配置属性来加载外部配置中心的配置信息； 
一些固定的不能被覆盖的属性； 
一些加密/解密的场景；
```

14、如何集成 Spring Boot 和 ActiveMQ？（spring-boot-starter-activemq 依赖关系。）

15、 请描述Spring Boot自动装配的过程

```
Spring Boot通过@EnableAutoConfiguration注解开启自动配置，加载spring.factories中注册的各种AutoConfiguration类，
当某个AutoConfiguration类满足其注解@Conditional指定的生效条件（Starters提供的依赖、配置或Spring容器中是否存在某个Bean等）时，实例化该AutoConfiguration类中定义的Bean（组件等），并注入Spring容器，就可以完成依赖框架的自动配置。
```



# MySQL篇

主键

索引

```
索引是一种特殊的文件(InnoDB数据表上的索引是表空间的一个组成部分)，它们包含着对数据表里所有 记录的引用指针。

索引是一种数据结构。数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、更新 数据库表中数据。索引的实现通常使用B树及其变种B+树。更通俗的说，索引就相当于目录。为了方便 查找书中的内容，通过对内容建立索引形成目录。而且索引是一个文件，它是要占据物理空间的。
缺点：1、时间：创建和维护都需要花费时间
2、空间：占用物理空间
```

回滚

1、原始jdbc使用流程

```
第一步：Class.forName()加载数据库连接驱动；
第二步：DriverManager.getConnection()获取数据连接对象;
第三步：根据SQL获取sql会话对象，有2种方式 Statement、PreparedStatement ;
第四步：执行SQL处理结果集，执行SQL前如果有参数值就设置参数值setXXX();
第五步：关闭结果集、关闭会话、关闭连接。
```

2、statement和preparedstatement的区别 

```
相同：PrerapedStatement和Statement都是接口、都可以实现对数据表的CRUD操作：增删改查
不同：PreparedStatement可以使用占位符,是预编译的,批处理比Statement效率高
 PreparedStatement 可以规避 Statement弊端：①拼串 ②sql注入问题
```

1、数据库的三范式是什么

```
第一范式：列不可再分 ，是确保每列的原子性
第二范式：行可以唯一区分，主键约束 要求每个表只描述一件事情
第三范式：除了主键以外的其他列都不传递依赖于主键列
且三大范式是一级一级依赖的，第二范式建立在第一范式上，第三范式 建立第一第二范式上。
```

2、MySQL数据库引擎有哪些

```
mysql常用引擎包括：MYISAM、Innodb、Memory、MERGE
```

3、说说InnoDB与MyISAM的区别

```
1. InnoDB支持事务，MyISAM不支持，对于InnoDB每一条SQL语言都默认封装成事务，自动提 交，这样会影响速度，所以最好把多条SQL语言放在begin和commit之间，组成一个事务；
2. InnoDB支持外键，而MyISAM不支持。对一个包含外键的InnoDB表转为MYISAM会失败；
3. InnoDB是聚集索引，数据文件是和索引绑在一起的，必须要有主键，通过主键索引效率很高。 但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该 过大，因为主键太大，其他索引也都会很大。而MyISAM是非聚集索引，数据文件是分离的， 索引保存的是数据文件的指针。主键索引和辅助索引是独立的。
4. InnoDB不保存表的具体行数，执行select count(*) from table时需要全表扫描。而MyISAM用 一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；
5. Innodb不支持全文索引，而MyISAM支持全文索引，查询效率上MyISAM要高；
```

4、数据库的事务

```
什么是事务？： 多条sql语句，要么全部成功，要么全部失败。
原子性(Atomic)组成一个事务的多个数据库操作是一个不可分割的原子单元，只有所有操作都成功， 整个事务才会提交。任何一个操作失败，已经执行的任何操作都必须撤销，让数据库返回初始 状态。
一致性(Consistency)：事务操作成功后，数据库所处的状态和它的业务规则是一致的。即数据不会被破坏。 如A转账100元给B，不管操作是否成功，A和B的账户总额是不变的。
隔离性(Isolation)：在并发数据操作时，不同的事务拥有各自的数据空间，它们的操作不会对彼此产生干 扰：一旦事务提交成功，事务中的所有操作都必须持久化到数据库中。
持久性 (Durabiliy)：一旦事务提交成功，事务中的所有操作都必须持久化到数据库中。
```

![image-20220414160552192](/Users/zhangdada/Library/Application Support/typora-user-images/image-20220414160552192.png)

5、索引是什么

```
索引是帮助MySQL高效获取数据的数据结构，好比是一本书 前面的目录，能加快数据库的查询速度。
索引，包括聚集索引、覆盖索引、组合索引、前缀索引、唯一索引等，没有特 别说明，默认都是使用B+树结构组织（多路搜索树，并不一定是二叉的）的索引。
```

6、SQL优化手段有哪些

```
1、查询语句中不要使用select * 
2、尽量减少子查询，使用关联查询（left join,right join,inner join）替代 
3、减少使用IN或者NOT IN ,使用exists，not exists或者关联查询语句替代 
4、or 的查询尽量用 union或者union all 代替(在确认没有重复数据或者不用剔除重复数据时， union all会更好) 
5、应尽量避免在 where 子句中使用!=或<>操作符，否则将引擎放弃使用索引而进行全表扫描。 
6、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表 扫描，
如： select id from t where num is null 可以在num上设置默认值0，确保表中num列没有 null值，
然后这样查询： select id from t where num=0
```



7、简单说一说drop、delete与truncate的区别

```
delete和truncate只删除表的数据不删除表的结构 
速度,一般来说: drop> truncate >delete delete 
语句是dml,这个操作会放到rollback segement中,事务提交之后才生效; 如果有相应的trigger,执行 的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger.
```

8、什么是视图

```
视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是 有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易， 相比多表查询。
```

9、 什么是内联接、左外联接、右外联接？

```
内联接（Inner Join）：匹配2张表中相关联的记录。 
左外联接（Left Outer Join）：除了匹配2张表中相关联的记录外，还会匹配左表中剩余的记录，右表中未匹配到的字段用NULL表示。 
右外联接（Right Outer Join）：除了匹配2张表中相关联的记录外，还会匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示。在判定左表和右表时，要根据表名出现在Outer Join 的左右位置关系。
```

9、SQL中怎么将行转成列？

```sql
使用 CASE...WHEN...THEN 语句实现行转列，参考如下代码：

SELECT userid, SUM(CASE `subject` WHEN '语文' THEN score ELSE 0 END) as '语文', SUM(CASE `subject` WHEN '数学' THEN score ELSE 0 END) as '数学', SUM(CASE `subject` WHEN '英语' THEN score ELSE 0 END) as '英语', SUM(CASE `subject` WHEN '政治' THEN score ELSE 0 END) as '政治'  FROM tb_score  GROUP BY userid
使用 IF() 函数实现行转列，参考如下代码：
SELECT userid, SUM(IF(`subject`='语文',score,0)) as '语文', SUM(IF(`subject`='数学',score,0)) as '数学', SUM(IF(`subject`='英语',score,0)) as '英语', SUM(IF(`subject`='政治',score,0)) as '政治'  FROM tb_score  GROUP BY userid
```

10、并发事务带来哪些问题?

```
脏读（Dirty read）:一个事务访问量一个数据修改后还没有返回数据库，被另一个事务读取到了。这个数据还没提交是脏数据
丢失修改（Lost to modify）:一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务 内的修改结果就被丢失，因此称为丢失修改。
不可重复读（Unrepeatableread）:一个事务多次访问同一数据，但是另一个事务访问修改，导致第一个事务读到的数据不一样
幻读：和不可重复读一样，第一个事务发现一些不存在的数据，像产生幻觉一样
区别：不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增 或者删除比如多次读取一条记录发现记录增多或减少了。（一个是值被修改，一个是多了数据）
```

11，事务隔离级别有哪些?MySQL的默认隔离级别是?

```
READ-UNCOMMITTED
READ-COMMITTED：是InnoDB 存储引擎默认使用
REPEATABLE-READ
SERIALIZABLE(可串行化)： 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐 个执行，这样事务之间就完全不可能产生干扰
```

![image-20220325210538504](/Users/zhangdada/Library/Application Support/typora-user-images/image-20220325210538504.png)

12，大表如何优化？

```
1. 限定数据的范围：务必禁止不带任何限制数据范围条件的查询语句。
2. 读/写分离：经典的数据库拆分方案，主库负责写，从库负责读；
3. 垂直分区：根据数据库里面数据表的相关性进行拆分。
		优点： 可以使得列数据变小，在查询时减少读取的Block数，减少I/O次数。 垂直分区可以简化表的结构，易于维护。 
		缺点： 主键会出现冗余，需要管理冗余列，并会引起Join操作，可以通过在应用层进行Join来解决，垂直分区会让事务变得更加复杂；
4. 水平分区：保持数据表结构不变，通过某种策略存储数据分片。这样每一片数据分散到不同的表或者库中，达 到了分布式的目的。 水平拆分可以支撑非常大的数据量。
垂直分区：就是按照表的种类再拆分 水平分区：就是将数据分成几个表存储
《Java工程师修炼之道》的作者推荐 尽量不要对数据进行分片，因为拆分会带来 逻辑、部署、运维的各种复杂度
数据库分片的两种常见方案：
客户端代理： 分片逻辑在应用端，封装在jar包中，通过修改或者封装JDBC层来实现。
中间件代理： 在应用和数据中间加了一个代理层。分片逻辑统一维护在中间件服务中。
```

13、分库分表之后,id 主键如何处理？

```
分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来支持。
生成全局 id 有下面这几种方式：
1、UUID：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯 一的名字的标示比如文件的名字。
2、数据库自增 id : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式 生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。
3、利用 redis 生成 id : 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系 统更加复杂，可用性降低，编码更加复杂，增加了系统成本。

```

14、 说说在 MySQL 中一条查询 SQL 是如何执行的？（select name from t_user where id=1）

```
1. 取得链接，使用使用到 MySQL 中的连接器。
2. 查询缓存，key 为 SQL 语句，value 为查询结果，如果查到就直接返回。不建议使用次缓存，（Mysql8.0后删除）
3. 分析器，分为词法分析和语法分析。
4. 优化器，是在表里有多个索引的时候，决定使用哪个索引；或者一个语句中存在多表关联的时 候（join），决定各个表的连接顺序。
5. 执行器，通过分析器让 SQL 知道你要干啥，通过优化器知道该怎么做，于是开始执行语句。
```

15、索引有什么优缺点？

```
1、提高数据检索速度，降低数据库IO成本，缩小表中需要查阅记录的数从而加快速度。
2、降低数据排序成本
1、占用存储空间，索引也是表，记录主键与索引字段
2、降低了更新表的速度，表的数据发生变化，对应的索引也发生变化
```

16、 MySQL 中 varchar 与 char 的区别？varchar(30) 中的 30 代表的涵义？-最多存放 30 个字符

```
长度是否可变
对效率要求高用 char，对空间使用要求高用 varchar。
```

17、 int(11) 中的 11 代表什么涵义？-不影响字段存储的范围，只影响展示效果。

18、 为什么 SELECT COUNT(*) FROM table 在 InnoDB 比 MyISAM 慢？

```
因为，InnoDB 是去实时统计结果，会全表扫描；而 MyISAM 内部维持了一个计数器，预存了结果，所以直接返回即可。
```

19. 说说 InnoDB 与 MyISAM 有什么区别？

```
MySQL 5.1 及之前的版本中，MyISAM 是默认的存储引擎，之后是InnoDb
MyISAM 不支持行级锁,会对整张表加锁，MyISAM 不支持事务和外键
MyISAM 可被压缩，存储空间较小，而且 MyISAM 在筛选大量数 据时非常快。
InnoDB 是事务型引擎，当事务异常提交时，会被回滚。同时，InnoDB 支持行锁。
InnoDB 需要更多存储空间，会在内存中建立其专用的缓冲池用于高速缓冲数据和索引。
InnoDB 支持自动奔溃恢复特性。

1、是否支持行级锁2、是否支持事物和奔溃后的安全恢复3、是否支持外健4、是否支持MVCC
```

20、MySQL 索引类型有哪些？

```
1、从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，RTree索引。
B+Tree索引 是B-Tree的改进版本，同时也是数据库索引索引所采用的存储结构。数据都在叶子节点上，并且增加了 顺序访问指针，每个叶子节点都指向相邻的叶子节点的地址。相比B-Tree来说，进行范围查找时只需要 查找两个节点，进行遍历即可。而B-Tree需要获取所有节点，相比之下B+Tree效率更高。
```

```
主键索引-索引列中的值必须是唯一的，不允许有空值。
普通索引-MySQL中基本索引类型，没有什么限制，允许在定义索引的列中插入重复值和空值。
唯一索引-索引列中的值必须是唯一的，但是允许为空值。
全文索引-只能在文本类型CHAR,VARCHAR,TEXT类型字段上创建全文索引。字段长度比较大时，如果创建普 通索引，在进行like模糊查询时效率比较低，这时可以创建全文索引。MyISAM和InnoDB中都可以 使用全文索引。
空间索引-MySQL在5.7之后的版本支持了空间索引，而且支持OpenGIS几何数据模型。MySQL在空间索引这 方面遵循OpenGIS几何数据模型规则。
前缀索引-在文本类型如CHAR,VARCHAR,TEXT类列上创建索引时，可以指定索引列的长度，但是数值类型不 能指定。
1. 单列索引
2. 组合索引
组合索引的使用，需要遵循最左前缀匹配原则（最左匹配原则）。一般情况下在条件允许的情 况下使用组合索引替代多个单列索引使用。
```

21、什么时候不要使用索引？

```
1. 经常增删改的列不要建立索引；
2. 有大量重复的列不建立索引；
3. 表记录太少不要建立索引。
```

22、说说什么是 MVCC？

```
多版本并发控制（MVCC=Multi-Version Concurrency Control），是一种用来解决读 - 写冲突的无 锁并发控制。也就是为事务分配单向增长的时间戳，为每个修改保存一个版本。版本与事务时间戳 关联，读操作只读该事务开始前的数据库的快照（复制了一份数据）。这样在读操作不用阻塞写操 作，写操作不用阻塞读操作的同时，避免了脏读和不可重复读。
```

24、说说 MVCC 的实现原理

```
MVCC 的目的就是多版本并发控制，在数据库中的实现，就是为了解决读写冲突，它的实现原理主 要是依赖记录中的 3 个隐式字段、undo 日志、Read View 来实现的。
```

26、 请说说 MySQL 数据库的锁？

```
1. 共享锁：不堵塞，多个用户可以同一时刻读取同一个资源，相互之间没有影响。
2. 排它锁：一个写操作阻塞其他的读锁和写锁，这样可以只允许一个用户进行写入，防止其他用 户读取正在写入的资源。
3. 表锁：系统开销最小，会锁定整张表，MyISAM 使用表锁。
4. 行锁：容易出现死锁，发生冲突概率低，并发高，InnoDB 支持行锁（必须有索引才能实现， 否则会自动锁全表，那么就不是行锁了）。
```

27、说说什么是锁升级？

```
MySQL 行锁只能加在索引上，如果操作不走索引，就会升级为表锁。
原因是 InnoDB 是将 primary key index 和相关的行数据共同放在 B+ 树的叶节点。InnoDB 一定会有一个 primary key，secondary index 查找的时候，也是通过找到对应的 primary，再找对应的数据行。
当非唯一索引上记录数超过一定数量时，行锁也会升级为表锁。
```

28、说说悲观锁和乐观锁

```
悲观的实现往往是依靠数据库提供的锁机 制，也只有数据库层面提供的锁机制才能真正保证数据访问的排他性，否则，即使在本系统汇总实 现了加锁机制，也是没有办法保证系统不会修改数据。
在悲观锁的情况下，为了保证事务的隔离性，就需要一致性锁定读。读取数据时给加锁，其它事务 无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。
一般是通过 为数据库表增加一个“version”字段来实现。读取出数据时，将此版本号一同读出，之后更新时，对 此版本号加一。此时，将提交数据的版本数据与数据库表对应记录的当前版本信息进行比对，如果 提交的数据版本号大于数据库表当前版本号，则予以更新，否则认为是过期数据。
```

29、怎样尽量避免死锁的出现？

```
1. 设置获取锁的超时时间，至少能保证最差情况下，可以退出程序，不至于一直等待导致死锁；
2. 设置按照同一顺序访问资源，类似于串行执行；
3. 避免事务中的用户交叉；
4. 保持事务简短并在一个批处理中；
5. 使用低隔离级别；
6. 使用绑定链接。
```

30、使用 MySQL 的索引应该注意些什么？



```
应尽量避免在WHERE子句中使用!=或<>操作符，否则将引放弃使用索引而进行全表扫描。优化器将无法通过索引来确定将要命中的行数，因此需要搜索该表的所有行。
应尽量避免在WHERE子句中使用OR来连接条件，否则将导致引整放弃使用素而进行全表扫描，如:SELECTIO FR OMtWHERE num=10ORnum=20。
应尽量避免在WHERE子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。
应尽量避免在WHERE子句中对字段进行函数操作，这将导致引放弃使用索引而进行全表扫描。
不要在WHERE子句中的=左边进行画数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。
使用索引注意
复合索引遵循最左前缀原则。
如果MySQL评估使用索引比全表扫描更慢，会放弃使用索引。如果此时想要索引，可以在语句中添加强制索引。
列类型是字符串类型，查询时一定要给值加引号，否则索引失效
LIKE查询，%不能在前，因为无法使用索引。如果需要模糊匹配，可以使用全文素引。
表字段为NULL也是不可以使用索引的。
字段是字符串类型的使用的时候，必须加引号，否则索引失效
```

32、主键和候选键有什么区别？

```
表格的每一行都由主键唯一标识,一个表只有一个主键。主键也是候选键。按照惯例，候选键可以被 指定为主键，并且可以用于任何外 键引用。
```

33、主键与索引有什么区别？

```
主键一定会创建一个唯一索引，但是有唯一索引的列不一定是主键；
主键不允许为空值，唯一索引列允许空值；
一个表只能有一个主键，但是可以有多个唯一索引；
主键可以被其他表引用为外键，唯一索引列不可以；
主键是一种约束，而唯一索引是一种索引，是表的冗余数据结构，两者有本
```

34、 MySQL 如何做到高可用方案？

```
1. MySQL 高可用：分库分表，通过 MyCat 连接多个 MySQL
2. MyCat 也得高可用：Haproxy，连接多个 MyCat
3. Haproxy 也得高可用：通过 keepalived 辅助 Haproxy
```

35、谈谈你对SQL注入的理解

```sql
QL注入的原理是将SQL代码伪装到输入参数中，传递到服务器解析并执行的一种攻击手法。也就是说，在一些对SERVER端发起的请求参数中植入一些SQL代码，SERVER端在执行SQL操作时，会拼接对应参数，同时也将一些SQL注入攻击的“SQL”拼接起来，导致会执行一些预期之外的操作。

select * from user where username='' or 1=1 #' and password='123456'
SQL中会将#及--以后的字符串当做注释处理
那么在";"之后相当于是另外一条新的SQL
```

36、如何解决SQL注入

```
1、严格的参数校验
参数校验就没得说了，在一些不该有特殊字符的参数中提前进行特殊字符校验即可。
2、SQL预编译
指的是在服务器启动时，MySQL Client把SQL语句的模板（变量采用占位符进行占位）发送给MySQL服务器，MySQL服务器对SQL语句的模板进行编译，编译之后根据语句的优化分析对相应的索引进行优化，在最终绑定参数时把相应的参数传送给MySQL服务器，直接进行执行，节省了SQL查询时间，以及MySQL服务器的资源，达到一次编译、多次执行的目的，除此之外，还可以防止SQL注入。
具体是怎样防止SQL注入的呢？实际上当将绑定的参数传到MySQL服务器，MySQL服务器对参数进行编译，即填充到相应的占位符的过程中，做了转义操作。我们常用的JDBC就有预编译功能，不仅提升性能，而且防止SQL注入。
```

37、WHERE和HAVING有什么区别？

```
1、WHERE是一个约束声明，使用WHERE约束来自数据库的数据，WHERE是在结果返回之前起作用的，WHERE中不能使用聚合函数。
2、HAVING是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在HAVING中可以使用聚合函数。另一方面，HAVING子句中不能使用除了分组字段和聚合函数之外的其他字段。
3、从性能的角度来说，HAVING子句中如果使用了分组字段作为过滤条件，应该替换成WHERE子句。因为WHERE可以在执行分组操作和计算聚合函数之前过滤掉不需要的数据，性能会更好。
```

38、Mysql的索引为什么用B+树

```
B+树由B树和索引顺序访问方法演化而来，它是为磁盘或其他直接存取辅助设备设计的一种平衡查找树，在B+树中，所有记录节点都是按键值的大小顺序存放在同一层的叶子节点，各叶子节点通过指针进行链接。
```

39、MySQL的Hash索引和B树索引有什么区别？

```
hash索引进行等值查询更快(一般情况下)，但是却无法进行范围查询。因为在hash索引中经过hash函数建立索引之后，索引的顺序与原顺序无法保持一致，不能支持范围查询。而B+树的的所有节点皆遵循(左节点小于父节点，右节点大于父节点，多叉树也类似)，天然支持范围。
hash索引不支持使用索引进行排序，原理同上。
hash索引不支持模糊查询以及多列索引的最左前缀匹配，原理也是因为hash函数的不可预测。
hash索引任何时候都避免不了回表查询数据，而B+树在符合某些条件(聚簇索引，覆盖索引等)的时候可以只通过索引完成查询。
hash索引虽然在等值查询上较快，但是不稳定，性能不可预测，当某个键值存在大量重复的时候，发生hash碰撞，此时效率可能极差。而B+树的查询效率比较稳定，对于所有的查询都是从根节点到叶子节点，且树的高度较低。
```

40、聚簇索引和非聚簇索引有什么区别？

```
在InnoDB存储引擎中，可以将B+树索引分为聚簇索引和辅助索引（非聚簇索引）。无论是何种索引，每个页的大小都为16KB，且不能更改。

聚簇索引是根据主键创建的一棵B+树，聚簇索引的叶子节点存放了表中的所有记录。辅助索引是根据索引键创建的一棵B+树，与聚簇索引不同的是，其叶子节点仅存放索引键值，以及该索引键值指向的主键。也就是说，如果通过辅助索引来查找数据，那么当找到辅助索引的叶子节点后，很有可能还需要根据主键值查找聚簇索引来得到数据，这种查找方式又被称为书签查找。因为辅助索引不包含行记录的所有数据，这就意味着每页可以存放更多的键值，因此其高度一般都要小于聚簇索引。
```



# Linux篇

1、 绝对路径用什么符号表示？当前目录、上层目录用什么表示？ 主目录用什么表示? 切换目录用什么命令？

2、 怎么查看当前进程？怎么执行退出？怎么查看当前路径？

```
查看当前进程： ps
ps -l 列出与本次登录有关的进程信息； 
ps -aux 查询内存中进程信息； 
ps -aux | grep * 查询 *进程的详细信息； 
top 查看内存中进程的动态信息； 
kill -9 pid 杀死进程。
执行退出： exit
查看当前路径： pwd
```

3、查看文件有哪些命令

```
vi 文件名 #编辑方式查看，可修改
cat 文件名 #显示全部文件内容
more 文件名 #分页显示文件内容
less 文件名 #与 more 相似，更好的是可以往前翻页
tail 文件名 #仅查看尾部，还可以指定行数
head 文件名 #仅查看头部,还可以指定行数
```

4、列举几个常用的Linux命令

```
列出文件列表：ls【参数 -a -l】 
创建目录和移除目录：mkdir rmdir 
用于显示文件后几行内容：tail，例如： tail -n 1000：显示最后1000行 
打包：tar -xvf 
打包并压缩：tar -zcvf 
查找字符串：grep 
显示当前所在目录：pwd创建空文件：touch 
编辑器：vim vi
```

# Redis篇

```
Redis 的全称是：Remote Dictionary.Server，本质上是一个 Key-Value 类型的内存数据库
因为是纯内存操作，Redis 的性能非常出色
```

1，为什么要用缓存-使用缓存的目的就是提升读写性能。

2，使用 Redis 有哪些好处？

```
读取速度快，因为数据存在内存中，所以数据获取快； 
支持多种数据结构，包括字符串、列表、集合、有序集合、哈希等； 
支持事务，且操作遵守原子性，即对数据的操作要么都执行，要么都不支持； 
还拥有其他丰富的功能，队列、主从复制、集群、数据持久化等功能。
```

3， 什么是 Redis？

```
Redis 是一个开源（BSD 许可）、基于内存、支持多种数据结构的存储系统，可以作为数据库、缓 存和消息中间件。
它支持的数据结构有字符串（strings）、哈希（hashes）、列表（lists）、集合 （sets）、有序集合（sorted sets）等，除此之外还支持 bitmaps、hyperloglogs 和地理空间（ geospatial ）索引半径查询等功能。

它内置了复制（Replication）、LUA 脚本（Lua scripting）、LRU 驱动事件（LRU eviction）、事 务（Transactions）和不同级别的磁盘持久化（persistence）功能，并通过 Redis 哨兵（哨兵）和 集群（Cluster）保证缓存的高可用性（High availability）。
```

4，为什么 使用 Redis 而不是用 Memcache 呢？

```
1、Redis ⽀持更丰富的数据类型（⽀持更复杂的应⽤场景） 不仅支持K-V还有list、set、hash
2、Redis ⽀持数据的持久化 物理内存用完，可以将一些数据交换到磁盘
3、分布式一主多从
4、Redis 可以定期保存到磁盘（持久化）
5、Memcache 的单个value最大 1m ， Redis 的单个value最大 512m 。
6、Redis 数据丢失后可以通过 aof 恢复
Redis 有灾难恢复机制。 因为可以把缓存中的数据持久化到磁盘上。
Redis 使⽤单线程的多路 IO 复⽤模 型。 （Redis 6.0 引⼊了多线程 IO ）
Redis ⽀持发布订阅模型、Lua 脚本、事务等功能，⽽ Memcached 不⽀持。并且，Redis ⽀持更多的编程语⾔。
```

5，为什么 Redis 单线程模型效率也能那么高？

```
1. C语言实现，效率高
2. 纯内存操作
3. 基于非阻塞的IO复用模型机制
4. 单线程的话就能避免多线程的频繁上下文切换问题
5. 丰富的数据结构（全称采用hash结构，读取速度非常快，对数据存储进行了一些优化，比如亚 索表，跳表等）
```

6，说说 Redis 的线程模型

```
7、Redis 内部使用文件事件处理器 file event handler ，这个文件事件处理器是单线程的
文件事件处理器的结构包含 4 个部分：
1. 多个 socket 。
2. IO 多路复用程序。
3. 文件事件分派器。
4. 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）。
```

7，为什么 Redis 需要把所有数据放到内存中？

```
Redis 将数据放在内存中有一个好处，那就是可以实现最快的对数据读取，如果数据存储在硬盘中，磁盘 I/O 会严重影响 Redis 的性能。而且 Redis 还提供了数据持久化功能，不用担心服务器重 启对内存中数据的影响。
```

8，Redis 的同步机制了解是什么？

```
Redis 支持主从同步、从从同步。如果是第一次进行主从同步，主节点需要使用 bgsave 命令，再将 后续修改操作记录到内存的缓冲区，等 RDB 文件全部同步到复制节点，复制节点接受完成后将 RDB 镜像记载到内存中。等加载完成后，复制节点通知主节点将复制期间修改的操作记录同步到复 制节点，即可完成同步过程。
```

9， pipeline 有什么好处，为什么要用 pipeline？

```
使用 pipeline（管道）的好处在于可以将多次 I/O 往返的时间缩短为一次，但是要求管道中执行的 指令间没有因果关系。
用 pipeline 的原因在于可以实现请求/响应服务器的功能，当客户端尚未读取旧响应时，它也可以 处理新的请求。如果客户端存在多个命令发送到服务器时，那么客户端无需等待服务端的每次响应 才能执行下个命令，只需最后一步从服务端读取回复即可。
```

10、Redis出现缓存穿透

```
缓存穿透说简单点就是⼤量请求的 key 根本不存在于缓存中，导致请求直接到了数据库上， 根本没有经过缓存这⼀层。
总结⼀下就是：
1. 缓存层不命中。
2. 存储层不命中，不将空结果写回缓存。
3. 返回空结果给客户端。

最⼤连接数⼀个还只是⼀个指标，cpu，内存，磁盘，⽹ 络等物理条件都是其运⾏指标，这些指标都会限制其并发能⼒

方案
1、⾸先做好参数校验，⼀些不合法的参数请求直接抛出异常信息返回给客户端。
2、缓存⽆效 key : 如果缓存和数据库都查不到某个 key 的数据就写⼀个到 redis 中去并设 置过期时间
3、布隆过滤器： 布隆过滤器是⼀个⾮常神奇的数据结构，通过它我们可以⾮常⽅便地判断 ⼀个给定数据是否存在于海量数据中。我们需要的就是判断 key 是否合法，有没有感觉布隆 过滤器就是我们想要找的那个“⼈”。
```

11、Redis出现缓存雪崩

```
缓存在同⼀时间⼤⾯积的失效，后⾯的请求 都直接落到了数据库上，造成数据库短时间内承受⼤量请求。
场景是：有⼀些被⼤量访问数据（热点缓存）在某⼀时刻⼤⾯积失效，导致 对应的请求直接落到了数据库上。

举个例⼦ ：秒杀开始 12 个⼩时之前，我们统⼀存放了⼀批商品到 Redis 中，设置的缓存过期时 间也是 12 个⼩时，那么秒杀开始的时候，这些秒杀的商品的访问直接就失效了。导致的情况就 是，相应的请求直接就落到了数据库上，就像雪崩⼀样可怕。

解决方法：
1. 采⽤ Redis 集群，避免单机出现问题整个缓存服务都没办法使⽤。
2. 限流，避免同时处理⼤量的请求。

针对热点缓存失效的情况： 
1. 设置不同的失效时间⽐如随机设置缓存的失效时间。
2. 缓存永不失效。
```

11、步隆过滤器

```
布隆过滤器在针对海量数据去重或者验证数据合法性的时候⾮常有⽤。布隆过滤器的本质实 际上是 “位(bit)数组”，也就是说每⼀个存⼊布隆过滤器的数据都只占⼀位。相⽐于我们平 时常⽤的的 List、Map 、Set 等数据结构，它占⽤空间更少并且效率更⾼，但是缺点是其 返回的结果是概率性的，⽽不是⾮常准确的。
```

12 、缓存数据的处理流程是怎样的？

```
1. 如果⽤户请求的数据在缓存中就直接返回。
2. 缓存中不存在的话就看数据库中是否存在。
3. 数据库中存在的话就更新缓存中的数据。
4. 数据库中不存在的话就返回空数据。
```

13、Redis 常⻅数据结构以及使⽤场景分析

```
1、string：string 数据结构是简单的 key-value 类型。
	常⽤命令: set,get,strlen,exists,dect,incr,setex 等等。
  应⽤场景 ：⼀般常⽤在需要计数的场景，⽐如⽤户的访问次数、热点⽂章的点赞转发数量等等。
2、list ：Redis的list的实现为⼀个双向链表，⽀持反向查找和遍历，更⽅便操作，不过带来了部分额外的内存开销。
	常⽤命令: rpush,lpop,lpush,rpop,lrange、llen 等。
	应⽤场景: 发布与订阅或者说消息队列、慢查询。
3、hash:hash 是⼀个 string 类型的 field 和 value 的映射表， 特别适合⽤于存储对象 hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。
	常⽤命令： hset,hmset,hexists,hget,hgetall,hkeys,hvals 等。
	应⽤场景: 系统中对象数据的存储。
4、set 类似于 Java 中的 HashSet 。Redis 中的 set 类型是⼀种⽆序集合，集合中的元 素没有先后顺序。
	常⽤命令： sadd,spop,smembers,sismember,scard,sinterstore,sunion 等。
	应⽤场景: 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景
5、sorted set 增加了⼀个权重参数 score，使得集合中的元素能够按 score 进⾏有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。
	常⽤命令： zadd,zcard,zscore,zrange,zrevrange,zrem 等。
	应⽤场景： 需要对数据根据某个权重进⾏排序的场景。⽐如在直播系统中，实时排⾏信息包 含直播间在线⽤户列表，各种礼物排⾏榜，弹幕消息（可以理解为按消息维度的消息排⾏ 榜）等信息。
```

14、Redis 单线程模型详解

```
Redis 基于 Reactor 模式来设计开发了⾃⼰的⼀套⾼效的事件处理模型 ，这套事件处理模型对应的是 Redis 中的⽂件事件处理器（file event handler）。由于⽂件事件处理器（file event handler）是单线程 ⽅式运⾏的，所以我们⼀般都说 Redis 是单线程模型。

Redis 通过IO 多路复⽤程序 来监听来⾃客户端的⼤量连接（或者说是监听多个 socket），它会 将感兴趣的事件及类型(读、写）注册到内核中并监听每个事件是否发⽣。
I/O 多路复⽤技术的使⽤让 Redis 不需要额外创建多余的线程来监听客户 端的⼤量连接，降低了资源的消耗
Redis 服务器是⼀个事件驱动程序，服务器需要处理两类事件： 1. ⽂件事件; 2. 时间事 件。
时间事件不需要多花时间了解，我们接触最多的还是 ⽂件事件（客户端进⾏读取写⼊等操作，涉 及⼀系列⽹络通信）。
多个 socket（客户端连接） 
IO 多路复⽤程序（⽀持多个客户端连接的关键） 
⽂件事件分派器（将 socket 关联到相应的事件处理器） 
事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）
```

15、Redis6.0 之前 为什么不使⽤多线程？

```
1. 单线程编程容易并且更容易维护；
2. Redis 的性能瓶颈不在 CPU ，主要在内存和⽹络；
3. 多线程就会存在死锁、线程上下⽂切换等问题，甚⾄会影响性能。
```

16、Redis6.0 之后为何引⼊了多线程？

```
Redis6.0 引⼊多线程主要是为了提⾼⽹络 IO 读写性能，因为这个算是 Redis 中的⼀个性能瓶颈 （Redis 的瓶颈主要受限于内存和⽹络）。
```

17、Redis 给缓存数据设置过期时间有啥⽤？

```
因为内存是有限的，如果缓存中的所有数据都是⼀直保存的话，分分钟直接Out of memory。
Redis中除了字符串类型有⾃⼰独有设置过期时间的命令 setex 外，其他⽅法都需要依靠 expire 命令来设置过期时间 。另外， persist 命令可以移除⼀个键的过期时间：
，⽐如我们的短信验证码可 能只在1分钟内有效，⽤户登录的 token 可能只在 1 天内有效。
```

18、Redis是如何判断数据是否过期的呢？

```
Redis 通过⼀个叫做过期字典（可以看作是hash表）来保存数据过期的时间。过期字典的键指向 Redis数据库中的某个key(键)，过期字典的值是⼀个long long类型的整数，这个整数保存了key所 指向的数据库键的过期时间（毫秒精度的UNIX时间戳）。
```

19、过期的数据的删除策略了解么？

```
1、惰性删除 ：只会在取出key的时候才对数据进⾏过期检查。这样对CPU最友好，但是可能会 造成太多过期 key 没有被删除。
2. 定期删除 ： 每隔⼀段时间抽取⼀批 key 执⾏删除过期key操作。并且，Redis 底层会通过限 制删除操作执⾏的时⻓和频率来减少删除操作对CPU时间的影响。
```

20、Redis 内存淘汰机制了解么？

```
1. volatile-lru（least recently used）：从已设置过期时间的数据集（server.db[i].expires） 中挑选最近最少使⽤的数据淘汰
2. volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
3. volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰
4. allkeys-lru（least recently used）：当内存不⾜以容纳新写⼊数据时，在键空间中，移除 最近最少使⽤的 key（这个是最常⽤的）
5. allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰
6. no-eviction：禁⽌驱逐数据，也就是说当内存不⾜以容纳新写⼊数据时，新写⼊操作会报 错。这个应该没⼈使⽤吧！
4.0 版本后增加以下两种：
7. volatile-lfu（least frequently used）：从已设置过期时间的数据集(server.db[i].expires)中 挑选最不经常使⽤的数据淘汰
8. allkeys-lfu（least frequently used）：当内存不⾜以容纳新写⼊数据时，在键空间中，移 除最不经常使⽤的 key
```

21、Redis 持久化机制(怎么保证 Redis 挂掉之后再重启数据可以进 ⾏恢复)

```
Redis 的⼀种持久化⽅式叫快照（snapshotting，RDB），另⼀种⽅式是只追加⽂件 （append-only file, AOF）
Redis 可以通过创建快照来获得存储在内存⾥⾯的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进⾏备份，可以将快照复制到其他服务器从⽽创建具有相同数据的服务器副本 （Redis 主从结构，主要⽤来提⾼ Redis 性能），还可以将快照留在原地以便重启服务器的时候 使⽤。
开启 AOF 持久化后每执⾏⼀条会更改 Redis 中的数据的命令，Redis 就会将该命令写⼊硬盘中 的 AOF ⽂件。AOF ⽂件的保存位置和 RDB ⽂件的位置相同，都是通过 dir 参数设置的，默认的 ⽂件名是 appendonly.aof。

在 Redis 的配置⽂件中存在三种不同的 AOF 持久化⽅式，它们分别是：
appendfsync always #每次有数据修改发⽣时都会写⼊AOF⽂件,这样会严重降低Redis的速度 
appendfsync everysec #每秒钟同步⼀次，显示地将多个写命令同步到硬盘 
appendfsync no #让操作系统决定何时进⾏同步

```

22、Redis事务

```
Redis 可以通过 MULTI，EXEC，DISCARD 和 WATCH 等命令来实现事务(transaction)功能。
使⽤ MULTI命令后可以输⼊多个命令。Redis不会⽴即执⾏这些命令，⽽是将它们放到队列，当 调⽤了EXEC命令将执⾏所有命令。

Redis 是不⽀持 roll back 的，因⽽不满⾜原⼦性的（⽽且不满⾜持久性）。
Redis中的事务就理解为 ：Redis事务提供了⼀种将多个命令请求打包的功能。然后， 再按顺序执⾏打包的所有命令，并且不会被中途打断。
```

23、如何保证缓存和数据库数据的⼀致性？

```
1. 缓存失效时间变短（不推荐，治标不治本） ：我们让缓存数据的过期时间变短，这样的话缓 存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适 ⽤。

2. 增加cache更新重试机制（常⽤）： 如果 cache 服务当前不可⽤导致缓存删除失败的话， 我们就隔⼀段时间进⾏重试，重试次数可以⾃⼰定。如果多次重试还是失败的话，我们可以 把当前更新失败的 key 存⼊队列中，等缓存服务可⽤之后，再将 缓存中对应的 key 删除即 可。
```

24、Redis 有哪些适合的场景？

```
（1）会话缓存（Session Cache）
最常用的一种使用 Redis 的情景是会话缓存（sessioncache），用 Redis 缓存会话比其他存储（如Memcached）的优势在于：Redis 提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失
（2）全页缓存（FPC）
除基本的会话 token 之外，Redis 还提供很简便的 FPC 平台。回到一致性问题，即使重启了 Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似 PHP本地 FPC。
（3）队列
Reids 在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得 Redis 能作为一个很好的消息队列平台来使用。Redis 作为队列使用的操作，就类似于本地程序语言（如 Python）对 list 的 push/pop操作。
（4）排行榜/计数器
```



# 网络篇

![image-20220504175533708](/Users/zhangdada/Library/Application Support/typora-user-images/image-20220504175533708.png)

1，HTTP 响应码有哪些？分别代表什么含义？

```
200：成功，Web 服务器成功处理了客户端的请求。 
301：永久重定向，当客户端请求一个网址的时候，Web 服务器会将当前请求重定向到另一个 网址，搜索引擎会抓取重定向后网页的内容并且将旧的网址替换为重定向后的网址。 
302：临时重定向，搜索引擎会抓取重定向后网页的内容而保留旧的网址，因为搜索引擎认为 重定向后的网址是暂时的。 
400：客户端请求错误，多为参数不合法导致 Web 服务器验参失败。 
404：未找到，Web 服务器找不到资源。 
500：Web 服务器错误，服务器处理客户端请求的时候发生错误。 
503：服务不可用，服务器停机。 504：网关超时。
```

2，Forward 和 Redirect 的区别？

```
浏览器 URL 地址：
Forward 是服务器内部的重定向，服务器内部请求某个 servlet，然后获取 响应的内容，浏览器的 URL 地址是不会变化的；Redirect 是客户端请求服务器，然后服务器给 客户端返回了一个 302 状态码和新的 location，客户端重新发起 HTTP 请求，服务器给客户端 响应 location 对应的 URL 地址，浏览器的 URL 地址发生了变化。
数据的共享：
Forward 是服务器内部的重定向，request 在重定向过程中是不变的,servlet 间是共享的。
Redirect 发起了两次 HTTP 请求分别使用不同的 request。
请求的次数：Forward 只有一次请求；Redirect 有两次请求。
```

3、 Get 和 Post 请求有哪些区别？

```
get 请求用来从服务器获取资源 post 请求用来向服务器提交数据
表单的提交方式：
get 请求直接将表单数据以 name1=value1&name2=value2 的形式拼接到 URL 上
（http://www. baidu.com/action?name1=value1&name2=value2），
多个参数参数值需要用 & 连接起来并 且用 ? 拼接到 action 后面；
post 请求将表单数据放到请求头或者请求的消息体中。
传输数据的大小限制：get 请求的参数会在地址栏明文显示，使用 URL 编码的文本格式传递参数；Post请求使用二进制数据多重编码传递数据
参数的编码：
缓存：get 请求可以被浏览器缓存被收藏为标签； post 请求不会被缓存也不能被收藏为标签。  
```

4、说说 TCP 与 UDP 的区别，以及各自的优缺点

```
1、TCP面向连接，发送数据之前要建立连接，UDP是不需要连接的
2、TCP提供可靠的服务，UDP不保证可靠交付。tcp通过校验和，重传控制，序号标识，滑动窗 口、确认应答实现可靠传输。
3、UDP实时性好，工作效率高，适用于高速传播
4、TCP是点到点；DUP支持一对一，一对多
5、TCP对系统资源要求较多，UDP对系统资源要求较少
```

5，说一下 HTTP 和 HTTPS 的区别

```
端口不同：连接方式不同前者是80后者是443
消耗资源不同：HTTPS通信会因为加解密的处理消耗更多的CPU和内存资源。
开销： HTTPS 通信需要证书，这类证书通常需要向认证机构申请或者付费购买。
```

6，说说HTTP、TCP、Socket 的关系是什么？

```
需要 IP 协议来连接网络 
TCP 是一种允许我们安全传输数据的机制，使用 TCP 协议来传输数据的 
HTTP 是 Web 服务器 和客户端使用的特殊协议。 
HTTP 基于 TCP 协议，所以可以使用 Socket 去建立一个 TCP 连接。
```

7，说一下HTTP的长连接与短连接的区别（实质上是TCP协议的长连接和短连接）

```
短：在HTTP/1.0中默认使用短链接,也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连 接，但任务结束就中断连接。
长：从HTTP/1.1起，默认使用长连接，用以保持连接特性。在使用长连接的情况下，当一个网页打开完 成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭。它有一个保持时间
```

8，TCP 为什么要三次握手，两次不行吗？为什么？因为需要考虑连接时丢包的问题

```
1、建立连接三次握手，服务端开启监听，等待客户度端的连接请求，服务端处于“收听”状态
客户端向服务端发起连接“同步发送” 选择初始序列号
服务端收到连接请求-“同步收到” 确认序列号
客户端收到服务端的确认-客户端进入“已建立连接”
服务端收到客户端的确认-服务端进入”已建立连接“
从三次握手的过程可以看出如果只有两次握手，那么客户端的起始序列号可以确认，服务端的起始 序列号将得不到确认。
```

9，说一下 TCP 粘包是怎么产生的？怎么解决粘包问题的？

```
TCP 传输数据基于字节流，从应用层到 TCP 传输层的多个数据包是一连串的字节流是没有边界的，而且 TCP 首部并没有记录数据包的长度
而 UDP 是基于数据报传输数据的，UDP 首部也记录了数 据报的长度，可以轻易的区分出不同的数据包的边界。
1、TCP 发送缓冲区剩余空间不足以发送一个完整的数据包，要发送的数据超过了最大报文长度的限制，将发生拆包；
要发送的数据包小于 TCP 发送缓冲区剩余空间，TCP 将多个数据包写满发送缓冲区一次发送出 去，接收端没有及时读取 TCP 发送缓冲区中的数据包，将发生粘包；
2、发送端给数据包添加首部，首部中添加数据包的长度属性
针对发送的数据包小于缓冲区大小的情况，发送端可以将不同的数据包规定成同样的长度，不 足这个长度的补充 0，
发送端通过给不同的数据包添加间隔符合确定边界，
```

10，TCP 如何保证可靠性

```
序列号和确认号机制：TCP 给发送的每⼀个包进⾏编号，接收⽅对数据包进⾏排序，把有序数据传送给应⽤ 层。
超时重发机制：当 TCP 发出⼀个段后，它启动⼀个定时器，等待⽬的端确认收到这个报⽂ 段。如果不能及时收到⼀个确认，将重发这个报⽂段。
对乱序数据包重新排序：
丢弃重复数据：TCP 的接收端会丢弃重复的数据。
流量控制：TCP 连接的每⼀⽅都有固定⼤⼩的缓冲空间，TCP 的接收端只允许发送端 发送接收端缓冲区能接纳的数据。当接收⽅来不及处理发送⽅的数据，能提示发送⽅降 低发送的速率，防⽌包丢失。TCP 使⽤的流量控制协议是可变⼤⼩的滑动窗⼝协议。 （TCP 利⽤滑动窗⼝实现流量控制）
```

11，OSI 的七层模型都有哪些？开放系统互连参考模型 (Open System Interconnect）

```
应用层：各种应用协议，如HTTP、FTP、SMTP
表示层：信息的语法语义以及他们的关联，加密解密、翻译转换、压缩解压缩
会话层：不同机器上的用户之间建立及管理回话
传输层：接受上一层的数据在必要的时候把数据进行分割，交给网络层，并且保证这些数据段有效到达对端
网络层：控制子网运行，如逻辑编址、分组传输、路由选择
数据链路层： 物理寻址，同时将原始比特流转变为逻辑传输线路
物理层：机械、电子、定时接口通信信道上的原始比特流传输
```

12，浏览器中输入：“www.woaijava.com”之后都发生了什么？ 请详细阐述

```
1、浏览器查找域名的IP地址（经过了浏览器缓存、系统缓存、hosts文件、路由器缓 存、 递归搜索根域名服务器。）

建立TCP/IP连接（三次握手具体过程）

2、由浏览器发送一个HTTP请求
经过路由器的转发，通过服务器的防火墙，该HTTP请求到达了服务器
3、服务器处理该HTTP请求，
4、返回一个HTML文件
5、浏览器解析该HTML文件，并且显示在浏览器端
HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。
```

13，如何实现跨域？（JSONP、CORS方式、代理方式）

```
当浏览器执行 JS 脚本的时候，会检测脚本要访问的协议、域名、端口号是不是和当前网址一致，
```

16，HTTP1.0、HTTP1.1、HTTP2.0的关系和区别

```
HTTP1.0：每次请求与服务器建立一个TCP连接,不跟踪每个客户端也不记录过去的请求
HTTP1.1: 持久连续，请求管道化、增加缓存处理、增加host字段，支持断点传输
HTTP2.0：二进制分帧、多路复用、头部压缩、服务器推送
```

17，说说HTTP协议与TCP/IP协议的关系

```
HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。
```

18，如何理解HTTP协议是无状态的？

```
指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。
无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是 UDP协议（无连接）。
```

20，长连接和短连接的优缺点？

```
长连接可以省去较多的TCP建立和关闭的操作，减少浪费，节约时间 。
，遇到恶意的连接时，保活功能就不够使了。
短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。
但如 果客户请求频繁，将在TCP的建立和关闭操作上浪费时间和带宽。
```

21，说说长连接短连接的操作过程

```
短连接的操作步骤是：建立连接——数据传输——关闭连接...建立连接——数据传输——关闭连
接长连接的操作步骤是：建立连接——数据传输...（保持连接）...数据传输——关闭连接
```

22，说说TCP三次握手和四次挥手的全过程

```
三次握手
第一次握手：客户端发送syn包(syn=x)到服务器，并进入SYN_SEND状态，等待服务器确认；
第二 次握手：服务器收到syn包，必须确认客户的SYN（ack=x+1），同时自己也发送一个SYN包 （syn=y），即SYN+ACK包，此时服务器进入SYN_RECV状态； 
第三次握手：客户端收到服务器的 SYN＋ACK包，向服务器发送确认包ACK(ack=y+1)，此包发送完毕，客户端和服务器进入 ESTABLISHED状态，完成三次握手。
四次挥手
第一次挥手：主动关闭方发送 一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在ﬁn包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关 闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。
第二次挥手：被动关闭方收 到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序 号）。
第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也 就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 
第四次挥手：主动关闭方收到 FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。
```

24、OSI这样分层有什么好处？

```
1. 人们可以很容易的讨论和学习协议的规范细节。
2. 层间的标准接口方便了工程模块化。
3. 创建了一个更好的互连环境。
4. 降低了复杂度，使程序更容易修改，产品开发的速度更快。
5. 每层利用紧邻的下层服务，更容易记住个层的功能。
```

25、说说TCP/IP四层网络模型

```
第一层 网络接口层 数据链路层 将⽹络层交下来的 IP 数据报组装成帧
第二层 网间层 是选择合适的⽹间路由和交换结点， 确保数据及时传送。
第三层 传输层 是负责向两台主机进程之间的通信提供通⽤的数据传输服务 主要使用TCP、UDP
第四层 应用层 任务是通过应⽤进程间的交互来完成特定⽹络应⽤。
```

26、说说域名解析详细过程？

27、 IP 地址分为几类，每类都代表什么，私网是哪些？

```
公共地址和私有地址两大类，公共地址可以在外网中随意访问，私有地址只能在内网访 问只有通过代理服务器才可以和外网通信。
```

28、Cookie的作⽤是什么?和Session有什么区别？

```
Cookie 和 Session都是⽤来跟踪浏览器⽤户身份的会话⽅式，但是两者的应⽤场景不太⼀样。
Cookie ⼀般⽤来保存⽤户信息 ⽐如①我们在 Cookie 中保存已经登录过得⽤户信息，下次访问 ⽹站的时候⻚⾯可以⾃动帮你登录的⼀些基本信息给填了；②⼀般的⽹站都会有保持登录也就是 说下次你再访问⽹站的时候就不需要重新登录了，这是因为⽤户登录的时候我们可以存放了⼀个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找⽤户即可(为了安全考虑，重新 登录⼀般要将 Token 重写)；③登录⼀次⽹站后访问⽹站其他⻚⾯不需要重新登录。Session 的 主要作⽤就是通过服务端记录⽤户的状态。 典型的场景是购物⻋，当你要添加商品到购物⻋的时 候，系统不知道是哪个⽤户操作的，因为 HTTP 协议是⽆状态的。服务端给特定的⽤户创建特定 的 Session 之后就可以标识这个⽤户并且跟踪这个⽤户了。
Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。
Cookie 存储在客户端中，⽽Session存储在服务器上，相对来说 Session 安全性更⾼。如果要在 Cookie 中存储⼀些敏感信息，不要直接写⼊ Cookie 中，最好能将 Cookie 信息加密然后使⽤到 的时候再去服务器端解密。
```



# 设计模式

（创建型、结构型、行为型）

1、说说什么是单例模式（单例对象的类必须保证只有一个实 例存在，整个系统只能使用一个对象实例。）

```
优点：不会频繁地创建和销毁对象，浪费系统资源。
（1）饿汉式单例模式的写法：线程安全 （2）懒汉式单例模式的写法：非线程安全 （3）双检锁单例模式的写法：线程安全
```

2、说说你对代理模式的理解（给某一个对象提供一个代理，并由代理对象控制对原对象的引用）通常说是静态代理

```
代理模式一定程度上降低了系统的耦合度； 可以灵活地隐藏被代理对象的部分功能和服务，也增加额外的功能和服务。
由于使用了代理模式，因此程序的性能没有直接调用性能高； 使用代理模式提高了代码的复杂度。
```

3、说说工厂模式

```
简单工厂模式又叫静态工厂方法模式，就是建立一个工厂类，对实现了同一接口的一些类进行 实例的创建。
实现了对责任的分 割，它提供了专门的工厂类用于创建对象
不易拓展和维护，一旦添加新的产品类型，就不得不修改工厂的创建逻辑；产品类型较多时，工厂的创建逻辑可能过于复杂。
```

4、抽象工厂模式

```
在简单工厂的基础上将未来可能需要修改的代码抽象出来，通过继承的方式让 子类去做决定。
抽象工厂里只声明方法，具体 的实现交给子类（子工厂）去实现，这个时候再有新增品类的需求，只需要新创建代码即可。
```

5、装饰器模式是什么（装饰器模式是指动态地给一个对象增加一些额外的功能，同时又不改变其结构。）

```
装饰器模式是指动态地给一个对象增加一些额外的功能，同时又不改变其结构。
```

6、代理模式和装饰器模式有什么区别？

```
都是结构型模式，代理模式重在访问权限的控制，而装饰器模式重在功能的加强。
```

7、模板方法模式（模板方法模式是指定义一个算法骨架，将具体内容延迟到子类去实现）

```
提高代码复用性：将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中； 
实现了反向控制：通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为， 实现了反向控制并且符合开闭原则。
```

8、知道享元模式吗？（享元模式的意图是复用对象，节省内存，前提是享元对象是不可 变对象。）

```
当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，
我们就可 以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。
```

9、享元模式和单例模式的区别？

```
单例模式是创建型模式，重在只能有一个对象。
享元模式是结构型模式，重在节约内存使 用，提升程序性能。
```

10、说说策略模式在我们生活的场景？

```
（策略模式是指定义一系列算法，将每个算法都封装起来，并且使他们之间可以相互替换。）
优点：遵循了开闭原则，扩展性良好。
缺点：随着策略的增加，对外暴露越来越多。
```

11、知道责任链模式吗？

```
是行为型设计模式之一，其将链中每一个节点看作是一个对象，每个节点处理的请求均不同， 且内部自动维护一个下一节点对象。当一个请求从链式的首端发出时，会沿着链的路径依次传递给 每一个节点对象，直至有对象处理这个请求为止。
1、解耦了请求与处理； 
2、请求处理者（节点对象）只需关注自己感兴趣的请求进行处理即可，对于不感兴趣的请求，直 接转发给下一级节点对象； 
3、具备链式传递处理请求功能，请求发送者无需知晓链路结构，只需等待请求处理结果； 
4、链路结构灵活，可以通过改变链路结构动态地新增或删减责任；
5、易于扩展新的请求处理类（节点），符合 开闭原则；
1、责任链路过长时，可能对请求传递处理效率有影响； 如果节点对象存在循环引用时，会造成死循环，导致系统崩溃；
```

12、了解过适配器模式么？

```
适配器模式是将一个类的接口变成客户端所期望的另一种接口，使原本因接口不匹配而无法一起工作的两个类能够在一起工作。
可以让两个没有关联的类一起运行，起着中间转换的作用； 灵活性好，不会破坏原有的系统。
过多地使用适配器，容易使代码结构混乱，如明明看到调用的是 A 接口，内部调用的却是 B 接口的实现。
```

13、知道观察者模式吗？

```
观察者模式是定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅模式、模型-视图模式、源-监听器模式或从属者模式。
```

# maven篇

1、什么是maven？maven主要服务于基于java平台的项目构建，依赖管理和项目信息管理。

2、Maven能为我们解决什么问题？

```
①添加第三方jar包②jar包之间的依赖关系③获取第三方jar包④将项目拆分为多个工程模块
```

3、说说maven有什么优缺点？

```
便于项目升级、有很多插件、简化了项目依赖管理
```

5、什么是Maven的坐标？

```
Maven其中一个核心的作用就是管理项目的依赖，引入我们所需的各种jar包等。
为了能自动化的解 析任何一个Java构件，Maven必须将这些Jar包或者其他资源进行唯一标识
```

6、讲一下maven的生命周期

Validate-complie-test-package-verify-install-deploy

7、说说你熟悉哪些maven命令？

8、如何解决依赖传递引起的版本冲突？可通过dependency的exclusion元素排除掉依赖。

9、说说maven的依赖原则-最短路径原则、pom文件申明顺序优先、覆写原则

10、说说依赖的解析机制？

11、说说插件的解析机制

# tomcat篇

1、Tomcat的缺省端口是多少，怎么修改？

2、tomcat 有哪几种Connector 运行模式(优化)？

```
BIO ：一个线程处理一个请求。
NIO ：利用Java的异步IO处理，可以通过少量的线程处理大量的请求。
APR ：即Apache Portable Runtime，从操作系统层面解决io阻塞问题。
```

3、Tomcat有几种部署方式？

```
利用Tomcat的自动部署
使用Manager App控制台部署
修改 conf/server.xml 文件部署
增加自定义的Web部署文件
```

4、tomcat容器是如何创建servlet类实例？用到了什么原理？

```
1. 当容器启动时，会读取在webapps目录下所有的web应用中的web.xml文件，然后对 xml文件 进行解析，并读取servlet注册信息。然后，将每个应用中注册的servlet类都进行加载，并通过 反射的方式实例化。（有时候也是在第一次请求时实例化）
2. 在servlet注册时加上1如果为正数，则在一开始就实例化，如果不写或为负数，则第一次请求 实例化。
```

5、tomcat 如何优化？

6、熟悉tomcat的哪些配置？

7、Tomcat是什么？

8，什么是Servlet呢？

```
如一个http请求到来：容器将请求封装为servlet中的 HttpServletRequest对象，调用init()，service()等方法输出response,由容器包装为httpresponse 返回给客户端的过程。
```

9、servlet生命周期

```
Web容器加载Servlet并将其实例化后，Servlet生命周期开始
init()方法进行Servlet的初始化；
请求到达时调用Servlet的service()方法，service()方法会根据需要调用与请求 对应的doGet或doPost等方法；
当服务器关闭或项目被卸载时服务器会将Servlet实例销毁，此时会调用Servlet 的destroy()方法。
```

9，什么是Servlet规范？

```
从 Jar 包上来说，Servlet 规范就是两个 Jar 文件。servlet-api.jar 和 jsp-api.jar，Jsp 也是一种 Servlet。
从package上来说，就是 javax.servlet 和 javax.servlet.http 两个包
从接口来说，就是规范了 Servlet 接口、Filter 接口、Listener 接口、ServletRequest 接口、 ServletResponse 接口等。类图如下：
```

10、为什么我们将tomcat称为Web容器或者Servlet容器 ？

11，tomcat是如何处理Http请求流程的？

12、tomcat结构目录有哪些?

13、如果客户端禁止 cookie 能实现 session 还能用吗？

```
1. 手动通过URL传值、隐藏表单传递Session ID。

2. 用文件、数据库等形式保存Session ID，在跨页过程中手动调用。
```

14、Servlet是线程安全的吗

```
多线程并发的读写会导致数据不同步的问题。
解决的办法是尽量不要定义name属性，而是要把name变量分别定义在doGet() 和doPost()方法内。虽然使用synchronized(name){}语句块可以解决问题，但 是会造成线程的等待，不是很科学的办法。
```



# 消息队列

当我们不使⽤消息队列的时候，所有的⽤户的请求会直接落到服务器，然后通过数据库或者 缓存响应。假如在⾼并发的场景下，如果没有缓存或者数据库承受不了这么⼤的压⼒的话， 就会造成响应速度缓慢，甚⾄造成数据库宕机。但是，在使⽤消息队列之后，⽤户的请求数 据发送给了消息队列之后就可以⽴即返回，再由消息队列的消费者进程从消息队列中获取数 据，异步写⼊数据库，不过要确保消息不被重复消费还要考虑到消息丢失问题。由于消息队 列服务器处理速度快于数据库，因此响应速度得到⼤幅改善。

消息队列具有很好的削峰作⽤的功能——即通过异步处理，将短 时间⾼并发产⽣的事务消息存储在消息队列中，从⽽削平⾼峰期的并发事务。

使⽤消息队列还可以降低系统耦合性。我们知道如果模块之间不存在直接调⽤，那么新增模 块或者修改模块就对其他模块影响较⼩，这样系统的可扩展性⽆疑更好⼀些。

MQ的问题

```
1. 系统可⽤性降低： 系统可⽤性在某种程度上降低，为什么这样说呢？在加⼊ MQ 之 前，你不⽤考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引⼊ MQ 之后你就需要 去考虑了！

2. 系统复杂性提⾼： 加⼊ MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的 情况、保证消息传递的顺序性等等问题！

3. ⼀致性问题： 我上⾯讲了消息队列可以实现异步，消息队列带来的异步确实可以提⾼ 系统响应速度。但是，万⼀消息的真正消费者并没有正确消费消息怎么办？这样就会导 致数据不⼀致的情况了!
```

# 操作系统

1、IO模型

```
BIO--同步阻塞 IO 模型
同步阻塞 IO 模型中，应用程序发起 read 调用后，会一直阻塞，直到在内核把数据拷贝 到用户空间。
NIO--同步非阻塞 IO 模型
同步非阻塞 IO 模型中，应用程序会一直发起 read 调用，等待数据从内核空间拷贝到用 户空间的这段时间里，线程依然是阻塞的，直到在内核把数据拷贝到用户空间。
IO 多路复用
IO 多路复用模型中，线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把 数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间->用户 空间）还是阻塞的，通过减少无效的系统调用，减少了对 CPU 资源的消耗。
AIO--异步 IO 模型
异步 IO 是基于事件和回调机制实现的，也就是应用操作之后会直接返回，不会堵塞在那 里，当后台处理完成，操作系统会通知相应的线程进行后续的操作。
```



1、内存管理机制主要是做什么？

```
操作系统的内存管理主要负责内存的分配与回收（malloc 函数：申请内存，free 函数：
释放内存），另外地址转换也就是将逻辑地址转换成相应的物理地址等功能也是操作系统内存管 理做的事情。
```

2、操作系统的内存管理机制了解吗？内存管理有哪⼏种⽅式?

```
连续分配管理⽅式和⾮连续分配管理⽅式
连续分配管理⽅式是指为⼀个⽤户程 序分配⼀个连续的内存空间，常⻅的如 块式管理 。
块式管理 ： 远古时代的计算机操系统的内存管理⽅式。将内存分为⼏个固定⼤⼩的块，每 个块中只包含⼀个进程。如果程序运⾏需要内存的话，操作系统就分配给它⼀块，如果程序 运⾏只需要很⼩的空间的话，分配的这块内存很⼤⼀部分⼏乎被浪费了。这些在每个块中未 被利⽤的空间，我们称之为碎⽚。

⾮连续分配管理⽅式允许⼀个程序 使⽤的内存分布在离散或者说不相邻的内存中，常⻅的如⻚式管理 和 段式管理
⻚式管理 ：把主存分为⼤⼩相等且固定的⼀⻚⼀⻚的形式，⻚较⼩，相对相⽐于块式管理的划分⼒度更⼤，提⾼了内存利⽤率，减少了碎⽚。⻚式管理通过⻚表对应逻辑地址和物理地 址。
段式管理 ： ⻚式管理虽然提⾼了内存利⽤率，但是⻚式管理其中的⻚实际并⽆任何实际意 义。 段式管理把主存分为⼀段段的，每⼀段的空间⼜要⽐⼀⻚的空间⼩很多 。但是，最重 要的是段是有实际意义的，每个段定义了⼀组逻辑信息，例如,有主程序段 MAIN、⼦程序段 X、数据段 D 及栈段 S 等。 段式管理通过段表对应逻辑地址和物理地址。

段⻚式管理机制 。段⻚式管理机制结合 了段式管理和⻚式管理的优点。简单来说段⻚式管理机制就是把主存先分成若⼲段，每个段⼜分 成若⼲⻚，也就是说 段⻚式管理机制 中段与段之间以及段的内部的都是离散的。
```

3、分⻚机制和分段机制对⽐

```
分⻚机制和分段机制都是为了提⾼内存利⽤率，较少内存碎⽚。 
⻚和段都是离散存储的，所以两者都是离散分配内存的⽅式。但是，每个⻚和段中的内 存是连续的。
区别：
⻚的⼤⼩是固定的，由操作系统决定；
⽽段的⼤⼩不固定，取决于我们当前运⾏的程 序。 
分⻚仅仅是为了满⾜操作系统内存管理的需求，⽽段是逻辑信息的单位，在程序中可以 体现为代码段，数据段，能够更好满⾜⽤户的需要。
```

4、逻辑地址和物理地址

```
，⽐如在 C 语⾔中，指针⾥⾯存 储的数值就可以理解成为内存⾥的⼀个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操 作系统决定。物理地址指的是真实物理内存中地址，更具体⼀点来说就是内存地址寄存器中的地 址。物理地址是内存单元真正的地址。
```

5、进程和线程

![image-20220410192945232](/Users/zhangdada/Library/Application Support/typora-user-images/image-20220410192945232.png)

⼀个进程中可以有多个线程，多个线程共享进程的堆和⽅法区 (JDK1.8 之后的 元空间)资源，但是每个线程有⾃⼰的程序计数器、虚拟机栈 和 本地⽅法栈。

总结： 线程是进程划分成的更⼩的运⾏单位,⼀个进程在其执⾏的过程中可以产⽣多个线程。线 程和进程最⼤的不同在于基本上各进程是独⽴的，⽽各线程则不⼀定，因为同⼀进程中的线程极 有可能会相互影响。线程执⾏开销⼩，但不利于资源的管理和保护；⽽进程正相反。

6、Linux常用指令

```
cat 命令 命令用于连接文件并打印到标准输出设备上 cat filename
chmod 命令 用于改变 linux 系统文件或目录的访问权限 chmod a+x t.log
chown 命令 将指定文件的拥有者改为指定的用户或组
cp 命令 将源文件复制至目标文件，或将多个源文件复制至目标目录。
find 命令 用于在文件树中查找文件，并作出相应的处理。
mv 命令 移动文件或修改文件名
rm 命令 删除一个目录中的一个或多个文件或目录
vim 命令 Vim是从 vi 发展出来的一个文本编辑器。
pwd 命令 命令用于查看当前工作目录路径。
kill 命令 发送指定的信号到相应进程。
```

7、进程的调度算法

```
先到先服务(FCFS)调度算法 : 从就绪队列中选择一个最先进入该队列的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时再 重新调度。

短作业优先(SJF)的调度算法 : 从就绪队列中选出一个估计运行时间最短的进程为之分配资源，使它立即执行并一直执行到完成或发生某事件而被阻塞放弃占用 CPU 时 再重新调度。

时间片轮转调度算法 : 时间片轮转调度是一种最古老，最简单，最公平且使用最广的算法，又称 RR(Round robin)调度。每个进程被分配一个时间段，称作它的时间 片，即该进程允许运行的时间。

多级反馈队列调度算法 ：前面介绍的几种进程调度的算法都有一定的局限性。如短 进程优先的调度算法，仅照顾了短进程而忽略了长进程 。多级反馈队列调度算法既能使高优先级的作业得到响应又能使短作业（进程）迅速完成。，因而它是目前 ，UNIX 操作系统采取的便是这种调度算法。被公认的一种较好的进程调度算法 

优先级调度 ： 为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据内存要求，时间要求或任何 其他资源要求来确定优先级。
```

 

# 代理模式

一、静态代理

静态代理中，我们对目标对象的每个方法的增强都是手动完成的，非常不灵活（比如接口一旦新增加方法，目标对象和代理对象都要进行修改） 且麻烦(需要对每个目标类都单独写一个代理类)。 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。

```
1. 定义一个接口及其实现类；
2. 创建一个代理类同样实现这个接口
3. 将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这 样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行 前后做一些自己想做的事情。
```

二、动态代理

相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个 代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( CGLIB）

JDK 动态代理--只能代理实现了接口的类。

```
InvocationHandler 接口和 Proxy 类是核心
Proxy 类中使用频率最高的方法是： newProxyInstance() ，这个方法主要用来生成一个代理对象。
1. loader :类加载器，用于加载代理对象。
2. interfaces : 被代理类实现的一些接口；
3. h : 实现了 InvocationHandler 接口的对象；
要实现动态代理的话，还必须需要实现 InvocationHandler 来自定义处理逻辑。
public interface InvocationHandler {
/** * 当你使用代理对象调用方法的时候实际会调用到这个方法 */ 
		public Object invoke(Object proxy, Method method, Object[] args) 
			throws Throwable;
}
1. proxy :动态生成的代理类
2. method : 与代理类对象调用的方法相对应
3. args : 当前 method 方法的参数
1. 定义一个接口及其实现类；
2. 自定义 InvocationHandler 并重写 invoke 方法，在 invoke 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑； 
3. 通过 Proxy.newProxyInstance(ClassLoader loader,Class<?>[]interfaces,InvocationHandler h) 方法创建代理对象；
```

CGLIB 动态代理

```
1. 定义一个类；
2. 自定义 MethodInterceptor 并重写 intercept 方法， intercept 用于拦截增强被代理类的方法，和 JDK 动态代理中的 invoke 方法类似；
3. 通过 Enhancer 类的 create() 创建代理类；
```

